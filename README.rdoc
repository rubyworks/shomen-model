= Shomen Documentation Specification

== Description

Shomen is an intermediary documentation model catered to Ruby. The 
specification is a flat mapping, without internal referencing, suitable for
storage in both YAML and JSON formats.

== Why?

By using a standard intermediary format, documentation parsers need only concern
themselves with a single output target. And documentation templates in turn only
need to concern themselves with a single input format to use regardless of the
parsing system that was used to generate it.

== Design By Example

We will use the following script, which would be located at 'lib/musicstore/song.rb'
in a project, as an example to elucidate the specification.

  # song.rb (c) 2010 John Doe

  require 'fileutils'

  # Toplevel namespace for my MusicStore application.
  module MusicStore

    # Where to store music store's configuration.
    CONFIG_DIRECTORY = "~/.config/musicstore"

    # Overridable setting for configuration directory.
    def self.config_directory
      @@config_directory ||= CONFIG_DIRECTORY
    end

    # Common methods for MusicStore classes.
    module MusicMixin
    end

    # This is the Song class.
    class Song
      include MusicMixin

      # Returns a String of the artists name.
      def artist    
      end

      # Play the song.
      # 
      # seconds - number of seconds to playback
      #
      # Returns Integer of forked process id.
      def play(seconds=nil)
      end

    end

  end

== Types

The Shomen specification is a mapping of typed entries. The keys to the
mapping are uniqe identifiers.

=== Metadata Type

The +metadata+ entry provides general information about the library or
application being documented, such as it's name, description and current
version. There will be only one +metadata+ entry in a given Shomen file,
thus it's index is the fixed key, "<code>(metadata)</code>".

  "(metadata)": {
      "!"           : "metadata",
      "name"        : "song",
      "title"       : "Song Program",
      "summary"     : "Program for Playing Songs",
      "description" : "Play songs the easy way using song.rb!",
      "created"     : "!date 2010-10-10"
  }

=== File Type

The +file+ type is used to house non-Ruby documentation documents, such as
a README. It's structure is very basic.

  "/README.rdoc": {
      "!"           : "file"
      "name"        : "README.rdoc",
      "path"        : "",
      "mtime"       : "2010-10-10 11:11:10",
      "text"        : "= Music Store README\n ..."
  }

=== Script Type

The +script+ type provides information about a ruby program _file_.

  "/musicstore/song.rb": {
      "!"           : "script",
      "name"        : "song.rb",
      "path"        : "musicstore",
      "loadpath"    : "lib",
      "mtime"       : "2010-10-10 11:11:10",
      "header"      : "song.rb (c) 2010 John Doe",
      "footer"      : "",
      "requires"    : ["fileutils"],
      "constants"   : ["MusicStore::CONFIG_DIRECTORY"],
      "modules"     : ["MusicStore", "MusicStore::MusicMixin"],
      "classes"     : ["MusicStore::Song"],
      "functions"   : ["MusicStore.config_directory"],
      "methods"     : ["MusicStore::MusicMixin#play", "MusicStore::MusicMixin#artist"]
  }

=== Module Type

The +module+ type describes a Ruby Module.

  "MusicStore": {
      "!"           : "module",
      "name"        : "MusicStore",
      "namespace"   : "",
      "includes"    : [],
      "extensions"  : [],
      "comment"     : "Common methods for MusicStore classes.",
      "constants"   : ["MusicStore::CONFIG_DIRECTORY"],
      "modules"     : ["MusicStore::MusicMixin"],
      "classes"     : ["MusicStore::Song"],
      "functions"   : [],
      "methods"     : []
  }

=== Class Type

The +class+ type describes a Ruby Class.

  "MusicStore::Song": {
      "!"           : "class",
      "name"        : "Song",
      "namespace"   : "MusicStore",
      "includes"    : ["MusicStore::SongMixin"],
      "extensions"  : [],
      "comment"     : "This is the Song class.",
      "constants"   : [],
      "modules"     : [],
      "classes"     : [],
      "functions"   : [],
      "methods"     : ["MusicStore::Song#artist", "MusicStore::Song#play"]
  }

We left the +methods+ entry with an elipses as it would contain method-type
entries for each of it's two methods. An example of which you can see below.

=== Constant Type

The +constant+ type describes a constant.

  "MusicStore::CONFIG_DIRECTORY": {
      "!"           : "constant",
      "name"        : "CONFIG_DIRECTORY",
      "namespace"   : "MusicStore"
      "comment"     : "Where to store music store's configuration."
  }

=== Method Type

The +method+ type describes an instance method.

  "MusicStore::Song#play": {
      "!"           : "method",
      "name"        : "play",
      "namespace"   : "MusicStore::Song",
      "comment"     : "Play the song.",
      "access"      : "public"
      "image"       : "(seconds=nil)",
      "interface"   : [
        'play(seconds=nil)'
      ],
      "arguments"   : [
        {
          "name"    : "seconds",
          "comment" : "number of seconds to playback"
        }
      ]
      "parameters"  : []
      "returns"     : [
        {
          "type"    : "Integer",
          "comment" : "forked process id"
        }
      ]
  }

=== Function Type

The +function+ type describes a class/module singleton method. The use of
the term "function" might seem an odd one, but it actually a term Matz has
used as a way to better conceptualize the character of class singleton
methods.

  "MusicStore::Song.config_directory": {
      "!"           : "function",
      "name"        : "config_directory",
      "namespace"   : "MusicStore",
      "comment"     : "Overridable setting for configuration directory.",
      "access"      : "public",
      "image"       : "",
      "interface"   : [],
      "arguments"   : [],
      "parameters"  : [],
      "returns"     : [
        {
          "type"    : "String",
          "comment" : "configuration directory"
        }
      ]
  }

== Fields

=== name

Every entry type has a name field. This simply give the local name of
the entry.

=== namepace

Every entry type, with the expection of +script+, has a +namespace+.
This gives the "nesting" of the entry within the code.

=== comment

Every entry has a +comment+ field, which store the comment given just
before the actual code for the entry.

=== constants

Used by scripts, modules and classes, provides a list of constants
found within it's context (excluding modules and classes, though they
are technically constant references too).

=== modules

Used by scripts, modules and classes, provides a list of modules
found within it's context.

=== classes

Used by scripts, modules and classes, provides a list of classes
found within it's context.

=== methods

Used by scripts, modules and classes, provides a list of instance methods
found within it's context.

=== functions

Used by scripts, modules and classes, provides a list of class-singleton
methods found within it's context.

=== access

The +method+ and +function+ types have +access+ types which can either be
+public+, +protected+ or +private+.

=== image

The +image+ is the literal interface of a method or function's
argument interface, e.g.

  'x(*args)'

=== interface

The +interface+ field provides a list of _intendend_ interfaces for a
method or function, as a subset of the literal interface.

For example:

  def x(*args)
    opts = Hash === args.last ? args.pop : {}
    name = args.first
    ...
  end

Might document the interface as:

  'interface': [
    'x(name, opts={})'
  ]


=== arguments

The +arguments+ field is used by the +method+ and +function+ types to provide
details about interface arguments.

  'arguments': [
    { 
      'name': 'name',
      'comment': 'name of x'
    },
    {
      'name': 'opts',
      'comment': 'runtime options for x'
    }
  ]

=== parameters

The +parametes+ field is used by the +method+ and +function+ types to provide
details about an interface's named paraemters. For example in the above +x+
method, +opts+ is used for named parameters. If there are specifically recognized
options, the +parameters+ field can be used to descrip them.

  'parameters': [
    { 
      'name': 'foo',
      'comment': 'foo description',
      'for': 'opts'
    }
  ]

Notice that arguments and parameters do not have a direct linkage to the 
interface they describe. While techincally, we could make +arguments+ and 
+parameters+ a subfield of the +interface+ as a mapping, available documentation
tools do not typically provide means for describing that level of detail.
The use of unique argument names is generally sufficient to communicate the
relationship. The +parameters+ field provides the +for+ subfield as an option
to make that relationship clearer.

=== returns

The +returns+ field, used by the +method+ and +function+ type, is a sequence of
possible return values. Ususally there is only one return value, but it is 
possible for there to be multiple ruturn values based on conditions
within the method. For example, a method might return a filename if a file
exists, but +nil+ otherwise, in which case the +returns+ field might look like:

  'returns': [
    {
      'type': 'String'
      'comment': 'filename'
    },
    {
      'type': 'nil',
      'comment': 'if no file is found'
    }
  }


== Guidelines for Documentation Parsers

Not all documentation systems will be able to produce all the information
that the Shomen standard supports. For instance RDoc doesn't have any means
of demarking return values. But this is to be expected. The documentaion
system should simply produce as much of the information as it can. Generators
have the responsiblity of gracefully handling missing information.


== Guidelines for Documentation Generators

As mentioned above, documentation generators need to gracefully hand missing
information.


== COPYING

Copyright (c) 2010 Thomas Sawyer

Shomen is distributed under the same terms as Ruby.

