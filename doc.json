{"(metadata)":{"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"}],"copyrights":[],"replacements":[],"conflicts":[],"requirements":[{"name":"rdoc","version":"3~"},{"name":"detroit","groups":["build"],"development":true}],"dependencies":[],"repositories":[{"uri":"git://github.com/rubyworks/shomen.git","scm":"git","name":"upstream"}],"resources":{"home":"http://rubyworks.github.com/shomen","work":"http://github.com/rubyworks/shomen"},"load_path":["lib"],"extra":{"manifest":"MANIFEST"},"source":[],"alternatives":[],"revision":0,"title":"Shomen","summary":"Standardized Object-Oriented Documentation Format","created":"2010-07-01","description":"Shomen defines a standard API documentaiton format for object-oriented software (Ruby programs in particular) which can be used by documentation interfaces, e.g. Hypervisor, to render API documentation","version":"0.1.0","name":"shomen_documentation_specification","date":"2011-09-24","path":"(metadata)"},"Shomen::Metadata::PWD":{"!":"constant","path":"Shomen::Metadata::PWD","name":"PWD","namespace":"Shomen::Metadata","comment":"Present working directoty.","format":"rdoc","value":"Dir.pwd","files":["/lib/shomen/metadata.rb"]},"Shomen::Metadata::SPEC_GLOB":{"!":"constant","path":"Shomen::Metadata::SPEC_GLOB","name":"SPEC_GLOB","namespace":"Shomen::Metadata","comment":"","format":"rdoc","value":"'{.ruby,.rubyspec}'","files":["/lib/shomen/metadata.rb"]},"Shomen::Metadata::GEMSPEC_GLOB":{"!":"constant","path":"Shomen::Metadata::GEMSPEC_GLOB","name":"GEMSPEC_GLOB","namespace":"Shomen::Metadata","comment":"","format":"rdoc","value":"'{.gemspec,*.gemspec}'","files":["/lib/shomen/metadata.rb"]},"Hash":{"!":"class","path":"Hash","name":"Hash","namespace":"","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Hash#to_h"],"accessors":[],"files":["/lib/shomen/core_ext/hash.rb"],"superclass":"Object"},"RDoc":{"!":"module","path":"RDoc","name":"RDoc","namespace":"","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":["RDoc::SourceCodeAccess","RDoc::Parser","RDoc::Generator"],"classes":["RDoc::TopLevel","RDoc::ClassModule","RDoc::AnyMethod","RDoc::Attr"],"methods":[],"accessors":[],"files":[]},"RDoc::AnyMethod":{"!":"class","path":"RDoc::AnyMethod","name":"AnyMethod","namespace":"RDoc","includes":["RDoc::SourceCodeAccess"],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/shomen/rdoc/extensions.rb"],"superclass":"Object"},"RDoc::Attr":{"!":"class","path":"RDoc::Attr","name":"Attr","namespace":"RDoc","includes":["RDoc::SourceCodeAccess"],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/shomen/rdoc/extensions.rb"],"superclass":"Object"},"RDoc::ClassModule":{"!":"class","path":"RDoc::ClassModule","name":"ClassModule","namespace":"RDoc","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["RDoc::ClassModule#with_documentation?","RDoc::ClassModule#document_self_or_methods"],"accessors":[],"files":["/lib/shomen/rdoc/extensions.rb"],"superclass":"Object"},"RDoc::Generator":{"!":"module","path":"RDoc::Generator","name":"Generator","namespace":"RDoc","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":["RDoc::Generator::Shomen"],"methods":[],"accessors":[],"files":[]},"RDoc::Generator::Shomen":{"!":"class","path":"RDoc::Generator::Shomen","name":"Shomen","namespace":"RDoc::Generator","includes":[],"extensions":[],"comment":"Shomen Adaptor for RDoc utilizes the rdoc tool to parse ruby source code\nto build a Shomen documenation file.\n\nRDoc is almost entirely a free-form documentation system, so it is not\npossible for Shomen to fully harness all the details it can support from\nthe RDoc documentation, such as method argument descriptions.\n---\nShomen Adaptor for RDoc\n\nOf course RDoc is almost entirely a free-form documentation system,\nso it is not possible for Shomen to fully harness all the details it\ncan support from the RDoc documentation.\n\nNOTE: This is probably slightly out of date with the current spec.","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["RDoc::Generator::Shomen.for","RDoc::Generator::Shomen#classes","RDoc::Generator::Shomen#classes_toplevel","RDoc::Generator::Shomen#files","RDoc::Generator::Shomen#files_toplevel","RDoc::Generator::Shomen#files_hash","RDoc::Generator::Shomen#methods_all","RDoc::Generator::Shomen#attributes_all","RDoc::Generator::Shomen#constants_all","RDoc::Generator::Shomen#class_dir","RDoc::Generator::Shomen#file_dir","RDoc::Generator::Shomen#shomen","RDoc::Generator::Shomen#generate","RDoc::Generator::Shomen.new","RDoc::Generator::Shomen#path_output_relative","RDoc::Generator::Shomen#generate_metadata","RDoc::Generator::Shomen#generate_constants","RDoc::Generator::Shomen#generate_classes","RDoc::Generator::Shomen#generate_methods","RDoc::Generator::Shomen#generate_documents","RDoc::Generator::Shomen#generate_scripts","RDoc::Generator::Shomen#complete_name","RDoc::Generator::Shomen#collect_methods","RDoc::Generator::Shomen#collect_attributes","RDoc::Generator::Shomen#method_name","RDoc::Generator::Shomen#mime_type","RDoc::Generator::Shomen#debug_msg","RDoc::Generator::Shomen#ref_item","RDoc::Generator::Shomen#ref_list","RDoc::Generator::Shomen#generate_attributes","RDoc::Generator::Shomen#generate_files"],"accessors":["RDoc::Generator::Shomen#options","RDoc::Generator::Shomen#path_base","RDoc::Generator::Shomen#path_output"],"files":["/lib/shomen/rdoc.rb","/lib/shomen/rdoc.0.rb"],"superclass":"Object"},"RDoc::Parser":{"!":"module","path":"RDoc::Parser","name":"Parser","namespace":"RDoc","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":["RDoc::Parser::C"],"methods":[],"accessors":[],"files":[]},"RDoc::Parser::C":{"!":"class","path":"RDoc::Parser::C","name":"C","namespace":"RDoc::Parser","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["RDoc::Parser::C#find_class_comment"],"accessors":[],"files":["/lib/shomen/rdoc/extensions.rb"],"superclass":"Object"},"RDoc::SourceCodeAccess":{"!":"module","path":"RDoc::SourceCodeAccess","name":"SourceCodeAccess","namespace":"RDoc","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["RDoc::SourceCodeAccess#source_code_raw","RDoc::SourceCodeAccess#source_code_location"],"accessors":[],"files":["/lib/shomen/rdoc/extensions.rb"]},"RDoc::TopLevel":{"!":"class","path":"RDoc::TopLevel","name":"TopLevel","namespace":"RDoc","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["RDoc::TopLevel#to_h"],"accessors":[],"files":["/lib/shomen/rdoc/extensions.rb"],"superclass":"Object"},"Shomen":{"!":"module","path":"Shomen","name":"Shomen","namespace":"","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":["Shomen::Model","Shomen::CLI"],"classes":["Shomen::YardAdaptor","Shomen::Metadata"],"methods":["Shomen.cli"],"accessors":[],"files":["/lib/shomen/model/module.rb","/lib/shomen/model/interface.rb","/lib/shomen/model/class.rb","/lib/shomen/model/attribute.rb","/lib/shomen/model/abstract.rb","/lib/shomen/model/document.rb","/lib/shomen/model/script.rb","/lib/shomen/model/constant.rb","/lib/shomen/model/method.rb","/lib/shomen/yard.rb","/lib/shomen/cli/yard.rb","/lib/shomen/cli/rdoc.rb","/lib/shomen/cli/abstract.rb","/lib/shomen/cli.rb","/lib/shomen/metadata.rb"]},"Shomen::CLI":{"!":"module","path":"Shomen::CLI","name":"CLI","namespace":"Shomen","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":["Shomen::CLI::YARDCommand","Shomen::CLI::RDocCommand","Shomen::CLI::Abstract"],"methods":[],"accessors":[],"files":["/lib/shomen/cli/yard.rb","/lib/shomen/cli/rdoc.rb","/lib/shomen/cli/abstract.rb"]},"Shomen::CLI::Abstract":{"!":"class","path":"Shomen::CLI::Abstract","name":"Abstract","namespace":"Shomen::CLI","includes":[],"extensions":[],"comment":"Command line interface base class.","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::CLI::Abstract.run","Shomen::CLI::Abstract#parse","Shomen::CLI::Abstract#option_yaml","Shomen::CLI::Abstract#option_json","Shomen::CLI::Abstract#option_force","Shomen::CLI::Abstract#option_debug","Shomen::CLI::Abstract#option_warn","Shomen::CLI::Abstract#option_help","Shomen::CLI::Abstract#root?"],"accessors":[],"files":["/lib/shomen/cli/abstract.rb"],"superclass":"Object"},"Shomen::CLI::RDocCommand":{"!":"class","path":"Shomen::CLI::RDocCommand","name":"RDocCommand","namespace":"Shomen::CLI","includes":[],"extensions":[],"comment":"RDoc command line interface.","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::CLI::RDocCommand.run","Shomen::CLI::RDocCommand.new","Shomen::CLI::RDocCommand#run","Shomen::CLI::RDocCommand#option_visibility","Shomen::CLI::RDocCommand#option_format","Shomen::CLI::RDocCommand#option_main"],"accessors":[],"files":["/lib/shomen/cli/rdoc.rb"],"superclass":"Abstract"},"Shomen::CLI::YARDCommand":{"!":"class","path":"Shomen::CLI::YARDCommand","name":"YARDCommand","namespace":"Shomen::CLI","includes":[],"extensions":[],"comment":"YARD command line interface.\n\nThe yard command provides a utility to generate\na Shomen doc file using YARD's .yardoc cache.","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::CLI::YARDCommand.run","Shomen::CLI::YARDCommand.new","Shomen::CLI::YARDCommand#run"],"accessors":[],"files":["/lib/shomen/cli/yard.rb"],"superclass":"Abstract"},"Shomen::Metadata":{"!":"class","path":"Shomen::Metadata","name":"Metadata","namespace":"Shomen","includes":["Enumerable"],"extensions":[],"comment":"Encapsulate metadata, which preferably comes from a .ruby file,\nbut can fallback to a gemspec.","format":"rdoc","constants":["Shomen::Metadata::PWD","Shomen::Metadata::SPEC_GLOB","Shomen::Metadata::GEMSPEC_GLOB"],"modules":[],"classes":[],"methods":["Shomen::Metadata.new","Shomen::Metadata#dotruby","Shomen::Metadata#gemspec","Shomen::Metadata#[]","Shomen::Metadata#size","Shomen::Metadata#each","Shomen::Metadata#to_h","Shomen::Metadata#generate_metadata","Shomen::Metadata#generate_metadata_from_spec","Shomen::Metadata#generate_metadata_from_gemspec"],"accessors":[],"files":["/lib/shomen/metadata.rb"],"superclass":"Object"},"Shomen::Model":{"!":"module","path":"Shomen::Model","name":"Model","namespace":"Shomen","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":["Shomen::Model::Module","Shomen::Model::Interface","Shomen::Model::Class","Shomen::Model::Attribute","Shomen::Model::AbstractPrime","Shomen::Model::Abstract","Shomen::Model::Document","Shomen::Model::Script","Shomen::Model::Constant","Shomen::Model::Method"],"methods":[],"accessors":[],"files":["/lib/shomen/model/module.rb","/lib/shomen/model/interface.rb","/lib/shomen/model/class.rb","/lib/shomen/model/attribute.rb","/lib/shomen/model/abstract.rb","/lib/shomen/model/document.rb","/lib/shomen/model/script.rb","/lib/shomen/model/constant.rb","/lib/shomen/model/method.rb"]},"Shomen::Model::Abstract":{"!":"class","path":"Shomen::Model::Abstract","name":"Abstract","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Abstract.new","Shomen::Model::Abstract#type"],"accessors":["Shomen::Model::Abstract#path","Shomen::Model::Abstract#tags"],"files":["/lib/shomen/model/abstract.rb"],"superclass":"AbstractPrime"},"Shomen::Model::AbstractPrime":{"!":"class","path":"Shomen::Model::AbstractPrime","name":"AbstractPrime","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"Baseclass for all model classes.","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::AbstractPrime.attr_accessor","Shomen::Model::AbstractPrime.type","Shomen::Model::AbstractPrime.new","Shomen::Model::AbstractPrime#[]","Shomen::Model::AbstractPrime#[]=","Shomen::Model::AbstractPrime#to_h"],"accessors":[],"files":["/lib/shomen/model/abstract.rb"],"superclass":"Object"},"Shomen::Model::Attribute":{"!":"class","path":"Shomen::Model::Attribute","name":"Attribute","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Attribute.type","Shomen::Model::Attribute.new"],"accessors":["Shomen::Model::Attribute#rw"],"files":["/lib/shomen/model/attribute.rb"],"superclass":"Method"},"Shomen::Model::Class":{"!":"class","path":"Shomen::Model::Class","name":"Class","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Class.type"],"accessors":["Shomen::Model::Class#superclass"],"files":["/lib/shomen/model/class.rb"],"superclass":"Module"},"Shomen::Model::Constant":{"!":"class","path":"Shomen::Model::Constant","name":"Constant","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Constant.type"],"accessors":["Shomen::Model::Constant#name","Shomen::Model::Constant#namespace","Shomen::Model::Constant#comment","Shomen::Model::Constant#format","Shomen::Model::Constant#value","Shomen::Model::Constant#files"],"files":["/lib/shomen/model/constant.rb"],"superclass":"Abstract"},"Shomen::Model::Document":{"!":"class","path":"Shomen::Model::Document","name":"Document","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Document.type"],"accessors":["Shomen::Model::Document#name","Shomen::Model::Document#path","Shomen::Model::Document#mtime","Shomen::Model::Document#text","Shomen::Model::Document#format"],"files":["/lib/shomen/model/document.rb"],"superclass":"Abstract"},"Shomen::Model::Interface":{"!":"class","path":"Shomen::Model::Interface","name":"Interface","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Interface.new"],"accessors":["Shomen::Model::Interface#signature","Shomen::Model::Interface#arguments","Shomen::Model::Interface#parameters","Shomen::Model::Interface#block","Shomen::Model::Interface#returns"],"files":["/lib/shomen/model/interface.rb"],"superclass":"AbstractPrime"},"Shomen::Model::Method":{"!":"class","path":"Shomen::Model::Method","name":"Method","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Method.new","Shomen::Model::Method#interfaces=","Shomen::Model::Method#to_h"],"accessors":["Shomen::Model::Method#name","Shomen::Model::Method#namespace","Shomen::Model::Method#comment","Shomen::Model::Method#format","Shomen::Model::Method#singleton","Shomen::Model::Method#declarations","Shomen::Model::Method#aliases","Shomen::Model::Method#alias_for","Shomen::Model::Method#interfaces","Shomen::Model::Method#returns","Shomen::Model::Method#dynamic","Shomen::Model::Method#file","Shomen::Model::Method#line","Shomen::Model::Method#source","Shomen::Model::Method#language","Shomen::Model::Method#parent"],"files":["/lib/shomen/model/method.rb"],"superclass":"Abstract"},"Shomen::Model::Module":{"!":"class","path":"Shomen::Model::Module","name":"Module","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Module.type"],"accessors":["Shomen::Model::Module#name","Shomen::Model::Module#namespace","Shomen::Model::Module#comment","Shomen::Model::Module#format","Shomen::Model::Module#includes","Shomen::Model::Module#extensions","Shomen::Model::Module#constants","Shomen::Model::Module#modules","Shomen::Model::Module#classes","Shomen::Model::Module#methods","Shomen::Model::Module#accessors","Shomen::Model::Module#files"],"files":["/lib/shomen/model/module.rb"],"superclass":"Abstract"},"Shomen::Model::Script":{"!":"class","path":"Shomen::Model::Script","name":"Script","namespace":"Shomen::Model","includes":[],"extensions":[],"comment":"","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::Model::Script.type"],"accessors":["Shomen::Model::Script#source","Shomen::Model::Script#text","Shomen::Model::Script#text=","Shomen::Model::Script#language","Shomen::Model::Script#name","Shomen::Model::Script#path","Shomen::Model::Script#mtime","Shomen::Model::Script#header","Shomen::Model::Script#footer","Shomen::Model::Script#requires","Shomen::Model::Script#constants","Shomen::Model::Script#modules","Shomen::Model::Script#classes","Shomen::Model::Script#class_methods","Shomen::Model::Script#methods"],"files":["/lib/shomen/model/script.rb"],"superclass":"Document"},"Shomen::YardAdaptor":{"!":"class","path":"Shomen::YardAdaptor","name":"YardAdaptor","namespace":"Shomen","includes":[],"extensions":[],"comment":"This adapter is used to convert YARD's documentation extracted\nfrom a local store (`.yardoc`) to Shomen's pure-data format.","format":"rdoc","constants":[],"modules":[],"classes":[],"methods":["Shomen::YardAdaptor.new","Shomen::YardAdaptor#generate"],"accessors":["Shomen::YardAdaptor#table"],"files":["/lib/shomen/yard.rb"],"superclass":"Object"},"Shomen::Model::AbstractPrime.attr_accessor":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::AbstractPrime.attr_accessor","name":"attr_accessor","namespace":"Shomen::Model::AbstractPrime","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"attr_accessor(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":11,"source":"# File lib/shomen/model/abstract.rb, line 11\n      def self.attr_accessor(name)\n        name = name.to_s\n        define_method(name) do\n          self[name]\n        end\n        define_method(name+'=') do |x|\n          self[name] = x\n        end\n      end","language":"ruby"},"Shomen.cli":{"!":"method","declarations":["class","public"],"path":"Shomen.cli","name":"cli","namespace":"Shomen","comment":"Command line interface. (YARD oriented for now).","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"cli(*argv)","arguments":[{"name":"*argv"}]}],"returns":[],"file":"/lib/shomen/cli.rb","line":8,"source":"# File lib/shomen/cli.rb, line 8\n  def self.cli(*argv)\n    case cmd = argv.shift\n    when 'server'\n      require 'shomen/server'\n    when 'yard'\n      require 'shomen/cli/yard'\n      CLI::YARDCommand.run(*argv)\n    when 'rdoc'\n      require 'shomen/cli/rdoc'\n      CLI::RDocCommand.run(*argv)\n    else\n      abort \"error: unrecognized command - #{cmd}\"\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen.for":{"!":"method","declarations":["class","public"],"path":"RDoc::Generator::Shomen.for","name":"for","namespace":"RDoc::Generator::Shomen","comment":"Standard generator factory method.","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"for(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":38,"source":"# File lib/shomen/rdoc.rb, line 38\n  def self.for(options)\n    new(options)\n  end","language":"ruby"},"Shomen::CLI::YARDCommand.new":{"!":"method","declarations":["class","public"],"path":"Shomen::CLI::YARDCommand.new","name":"new","namespace":"Shomen::CLI::YARDCommand","comment":"New Shomen YARD command line interface.","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new()","arguments":[]}],"returns":[],"file":"/lib/shomen/cli/yard.rb","line":20,"source":"# File lib/shomen/cli/yard.rb, line 20\n      def initialize\n      end","language":"ruby"},"Shomen::Model::Method.new":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Method.new","name":"new","namespace":"Shomen::Model::Method","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(settings={})","arguments":[{"name":"settings","default":"{}"}]}],"returns":[],"file":"/lib/shomen/model/method.rb","line":12,"source":"# File lib/shomen/model/method.rb, line 12\n      def initialize(settings={})\n        super(settings)\n        @table['declarations'] ||= []\n      end","language":"ruby"},"Shomen::Model::Interface.new":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Interface.new","name":"new","namespace":"Shomen::Model::Interface","comment":"TODO: validate that there is an interface image.","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(settings={})","arguments":[{"name":"settings","default":"{}"}]}],"returns":[],"file":"/lib/shomen/model/interface.rb","line":11,"source":"# File lib/shomen/model/interface.rb, line 11\n      def initialize(settings={})\n        #@table = {'arguments'=>[], 'parameters'=>[]}\n        super(settings)\n      end","language":"ruby"},"Shomen::CLI::RDocCommand.new":{"!":"method","declarations":["class","public"],"path":"Shomen::CLI::RDocCommand.new","name":"new","namespace":"Shomen::CLI::RDocCommand","comment":"New RDoc command line interface.","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new()","arguments":[]}],"returns":[],"file":"/lib/shomen/cli/rdoc.rb","line":20,"source":"# File lib/shomen/cli/rdoc.rb, line 20\n      def initialize\n        begin\n          gem 'rdoc'\n        rescue\n        end\n      end","language":"ruby"},"Shomen::YardAdaptor.new":{"!":"method","declarations":["class","public"],"path":"Shomen::YardAdaptor.new","name":"new","namespace":"Shomen::YardAdaptor","comment":"New adaptor.","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/shomen/yard.rb","line":17,"source":"# File lib/shomen/yard.rb, line 17\n    def initialize(options)\n      @db    = options[:db]    || '.yardoc'\n      @files = options[:files] || ['lib', 'README*']\n    end","language":"ruby"},"Shomen::Model::AbstractPrime.new":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::AbstractPrime.new","name":"new","namespace":"Shomen::Model::AbstractPrime","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(settings={})","arguments":[{"name":"settings","default":"{}"}]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":27,"source":"# File lib/shomen/model/abstract.rb, line 27\n      def initialize(settings={})\n        @table = {}\n        settings.each do |k,v|\n          s = \"#{k}=\".gsub('-','_')\n          __send__(s,v)\n        end\n      end","language":"ruby"},"RDoc::Generator::Shomen.new":{"!":"method","declarations":["class","public"],"path":"RDoc::Generator::Shomen.new","name":"new","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":144,"source":"# File lib/shomen/rdoc.rb, line 144\n  def initialize(options)\n    @options = options\n    #@options.diagram = false  # why?\n\n    @path_base   = Pathname.pwd.expand_path\n\n    # TODO: This is probably not needed any more.\n    @path_output = Pathname.new(@options.op_dir).expand_path(@path_base)\n  end","language":"ruby"},"Shomen::Model::Attribute.new":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Attribute.new","name":"new","namespace":"Shomen::Model::Attribute","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(settings={})","arguments":[{"name":"settings","default":"{}"}]}],"returns":[],"file":"/lib/shomen/model/attribute.rb","line":13,"source":"# File lib/shomen/model/attribute.rb, line 13\n      def initialize(settings={})\n        super(settings)\n        self['!'] = settings['singleton'] ? 'class-attribute' : 'attribute'\n      end","language":"ruby"},"Shomen::Metadata.new":{"!":"method","declarations":["class","public"],"path":"Shomen::Metadata.new","name":"new","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new()","arguments":[]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":15,"source":"# File lib/shomen/metadata.rb, line 15\n    def initialize\n      @data = (\n        data = {}\n        if dotruby\n          data.merge!(YAML.load_file(dotruby))\n        elsif gemspec\n          # prefereably use dotruby library to convert,\n          # but wait until it's more mainstream\n          require 'rubygems/specification'\n          spec = ::Gem::Specification.load(gemspec)\n          data['name']        = spec.name,\n          data['title']       = spec.name.capitalize,\n          data['version']     = spec.version.to_s,\n          data['authors']     = [spec.author],\n          data['description'] = spec.description,\n          data['summary']     = spec.summary,\n          data['resources']   = {'homepage' => spec.homepage}\n        else\n          data['name'] = File.basename(Dir.pwd)\n        end\n        data['path'] = '(metadata)'\n        data\n      )\n    end","language":"ruby"},"Shomen::Model::Abstract.new":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Abstract.new","name":"new","namespace":"Shomen::Model::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"new(settings={})","arguments":[{"name":"settings","default":"{}"}]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":64,"source":"# File lib/shomen/model/abstract.rb, line 64\n      def initialize(settings={})\n        super(settings)\n        @table['!'] = self.class.type\n      end","language":"ruby"},"Shomen::CLI::YARDCommand.run":{"!":"method","declarations":["class","public"],"path":"Shomen::CLI::YARDCommand.run","name":"run","namespace":"Shomen::CLI::YARDCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"run(*argv)","arguments":[{"name":"*argv"}]}],"returns":[],"file":"/lib/shomen/cli/yard.rb","line":15,"source":"# File lib/shomen/cli/yard.rb, line 15\n      def self.run(*argv)\n        new.run(argv)\n      end","language":"ruby"},"Shomen::CLI::RDocCommand.run":{"!":"method","declarations":["class","public"],"path":"Shomen::CLI::RDocCommand.run","name":"run","namespace":"Shomen::CLI::RDocCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"run(*argv)","arguments":[{"name":"*argv"}]}],"returns":[],"file":"/lib/shomen/cli/rdoc.rb","line":15,"source":"# File lib/shomen/cli/rdoc.rb, line 15\n      def self.run(*argv)\n        new.run(argv)\n      end","language":"ruby"},"Shomen::CLI::Abstract.run":{"!":"method","declarations":["class","public"],"path":"Shomen::CLI::Abstract.run","name":"run","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"run(*arg)","arguments":[{"name":"*arg"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":10,"source":"# File lib/shomen/cli/abstract.rb, line 10\n      def self.run(*arg)\n        new.run(*argv)\n      end","language":"ruby"},"Shomen::Model::Constant.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Constant.type","name":"type","namespace":"Shomen::Model::Constant","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/constant.rb","line":10,"source":"# File lib/shomen/model/constant.rb, line 10\n      def self.type; 'constant'; end","language":"ruby"},"Shomen::Model::Script.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Script.type","name":"type","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/script.rb","line":10,"source":"# File lib/shomen/model/script.rb, line 10\n      def self.type; 'script'; end","language":"ruby"},"Shomen::Model::AbstractPrime.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::AbstractPrime.type","name":"type","namespace":"Shomen::Model::AbstractPrime","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":22,"source":"# File lib/shomen/model/abstract.rb, line 22\n      def self.type\n        name.split('::').last.downcase\n      end","language":"ruby"},"Shomen::Model::Document.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Document.type","name":"type","namespace":"Shomen::Model::Document","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/document.rb","line":10,"source":"# File lib/shomen/model/document.rb, line 10\n      def self.type\n        'document'\n      end","language":"ruby"},"Shomen::Model::Module.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Module.type","name":"type","namespace":"Shomen::Model::Module","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/module.rb","line":11,"source":"# File lib/shomen/model/module.rb, line 11\n      def self.type; 'module'; end","language":"ruby"},"Shomen::Model::Class.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Class.type","name":"type","namespace":"Shomen::Model::Class","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/class.rb","line":10,"source":"# File lib/shomen/model/class.rb, line 10\n      def self.type; 'class'; end","language":"ruby"},"Shomen::Model::Attribute.type":{"!":"method","declarations":["class","public"],"path":"Shomen::Model::Attribute.type","name":"type","namespace":"Shomen::Model::Attribute","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":true,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/attribute.rb","line":10,"source":"# File lib/shomen/model/attribute.rb, line 10\n      def self.type; 'attribute'; end","language":"ruby"},"Shomen::Metadata#[]":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#[]","name":"[]","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"[](name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":55,"source":"# File lib/shomen/metadata.rb, line 55\n    def [](name)\n      @data[name]\n    end","language":"ruby"},"Shomen::Model::AbstractPrime#[]":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::AbstractPrime#[]","name":"[]","namespace":"Shomen::Model::AbstractPrime","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"[](k)","arguments":[{"name":"k"}]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":36,"source":"# File lib/shomen/model/abstract.rb, line 36\n      def [](k)\n        @table[k.to_s]\n      end","language":"ruby"},"Shomen::Model::AbstractPrime#[]=":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::AbstractPrime#[]=","name":"[]=","namespace":"Shomen::Model::AbstractPrime","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"[]=(k,v)","arguments":[{"name":"k"},{"name":"v"}]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":41,"source":"# File lib/shomen/model/abstract.rb, line 41\n      def []=(k,v)\n        @table[k.to_s] = v\n      end","language":"ruby"},"RDoc::Generator::Shomen#attributes_all":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#attributes_all","name":"attributes_all","namespace":"RDoc::Generator::Shomen","comment":"List of all attributes in all classes and modules.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"attributes_all()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":89,"source":"# File lib/shomen/rdoc.rb, line 89\n  def attributes_all\n    @attributes_all ||= classes.map{ |m| m.attributes }.flatten.sort\n  end","language":"ruby"},"RDoc::Generator::Shomen#class_dir":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#class_dir","name":"class_dir","namespace":"RDoc::Generator::Shomen","comment":"RDoc needs this to function.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"class_dir()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":104,"source":"# File lib/shomen/rdoc.rb, line 104\n  def class_dir ; nil ; end","language":"ruby"},"RDoc::Generator::Shomen#classes":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#classes","name":"classes","namespace":"RDoc::Generator::Shomen","comment":"In the world of the RDoc Generators #classes is the same\nas #all_classes_and_modules. Well, except that its sorted \ntoo. For classes sans modules, see #types.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"classes()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":54,"source":"# File lib/shomen/rdoc.rb, line 54\n  def classes\n    @classes ||= RDoc::TopLevel.all_classes_and_modules.sort\n  end","language":"ruby"},"RDoc::Generator::Shomen#classes_toplevel":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#classes_toplevel","name":"classes_toplevel","namespace":"RDoc::Generator::Shomen","comment":"Only toplevel classes and modules.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"classes_toplevel()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":59,"source":"# File lib/shomen/rdoc.rb, line 59\n  def classes_toplevel\n    @classes_toplevel ||= classes.select {|klass| !(RDoc::ClassModule === klass.parent) }\n  end","language":"ruby"},"RDoc::Generator::Shomen#collect_attributes":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#collect_attributes","name":"collect_attributes","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"collect_attributes(class_module, singleton=false)","arguments":[{"name":"class_module"},{"name":"singleton","default":"false"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":475,"source":"# File lib/shomen/rdoc.rb, line 475\n  def collect_attributes(class_module, singleton=false)\n    list = []\n    class_module.attributes.each do |a|\n      next if singleton ^ a.singleton\n      #p a.rw\n      #case a.rw\n      #when :write, 'W'\n      #  list << \"#{method_name(a)}=\"\n      #else\n        list << method_name(a)\n      #end\n    end\n    list.uniq\n  end","language":"ruby"},"RDoc::Generator::Shomen#collect_methods":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#collect_methods","name":"collect_methods","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"collect_methods(class_module, singleton=false)","arguments":[{"name":"class_module"},{"name":"singleton","default":"false"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":466,"source":"# File lib/shomen/rdoc.rb, line 466\n  def collect_methods(class_module, singleton=false)\n    list = []\n    class_module.method_list.each do |m|\n      next if singleton ^ m.singleton\n      list << method_name(m)\n    end\n    list.uniq\n  end","language":"ruby"},"RDoc::Generator::Shomen#complete_name":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#complete_name","name":"complete_name","namespace":"RDoc::Generator::Shomen","comment":"Returns String of fully qualified name.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"complete_name(name, namespace)","arguments":[{"name":"name"},{"name":"namespace"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":457,"source":"# File lib/shomen/rdoc.rb, line 457\n  def complete_name(name, namespace)\n    if name !~ /^#{namespace}/\n      \"#{namespace}::#{name}\"\n    else\n      name\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#constants_all":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#constants_all","name":"constants_all","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"constants_all()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":94,"source":"# File lib/shomen/rdoc.rb, line 94\n  def constants_all\n    @constants_all ||= classes.map{ |c| c.constants }.flatten\n  end","language":"ruby"},"RDoc::Generator::Shomen#debug_msg":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#debug_msg","name":"debug_msg","namespace":"RDoc::Generator::Shomen","comment":"Output progress information if rdoc debugging is enabled","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"debug_msg(msg)","arguments":[{"name":"msg"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":514,"source":"# File lib/shomen/rdoc.rb, line 514\n  def debug_msg(msg)\n    return unless $DEBUG_RDOC\n    case msg[-1,1]\n      when '.' then tab = \"= \"\n      when ':' then tab = \"== \"\n      else          tab = \"* \"\n    end\n    $stderr.puts(tab + msg)\n  end","language":"ruby"},"RDoc::ClassModule#document_self_or_methods":{"!":"method","declarations":["instance","public"],"path":"RDoc::ClassModule#document_self_or_methods","name":"document_self_or_methods","namespace":"RDoc::ClassModule","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"document_self_or_methods()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc/extensions.rb","line":28,"source":"# File lib/shomen/rdoc/extensions.rb, line 28\n  def document_self_or_methods\n    document_self || method_list.any?{ |m| m.document_self }\n  end","language":"ruby"},"Shomen::Metadata#dotruby":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#dotruby","name":"dotruby","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"dotruby()","arguments":[]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":41,"source":"# File lib/shomen/metadata.rb, line 41\n    def dotruby\n      file = File.join(PWD, '.ruby')\n      return nil unless File.exist?(file)\n      file\n    end","language":"ruby"},"Shomen::Metadata#each":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#each","name":"each","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"each(&blk)","arguments":[],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/shomen/metadata.rb","line":65,"source":"# File lib/shomen/metadata.rb, line 65\n    def each(&blk)\n      @data.each(&blk)\n    end","language":"ruby"},"RDoc::Generator::Shomen#file_dir":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#file_dir","name":"file_dir","namespace":"RDoc::Generator::Shomen","comment":"RDoc needs this to function.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"file_dir()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":107,"source":"# File lib/shomen/rdoc.rb, line 107\n  def file_dir  ; nil ; end","language":"ruby"},"RDoc::Generator::Shomen#files":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#files","name":"files","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"files()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":64,"source":"# File lib/shomen/rdoc.rb, line 64\n  def files\n    @files ||= (\n      @files_rdoc.select{ |f| f.parser != RDoc::Parser::Simple }\n    )\n  end","language":"ruby"},"RDoc::Generator::Shomen#files_hash":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#files_hash","name":"files_hash","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"files_hash()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":79,"source":"# File lib/shomen/rdoc.rb, line 79\n  def files_hash\n    @files ||= RDoc::TopLevel.files_hash\n  end","language":"ruby"},"RDoc::Generator::Shomen#files_toplevel":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#files_toplevel","name":"files_toplevel","namespace":"RDoc::Generator::Shomen","comment":"List of toplevel files. RDoc supplies this via the #generate method.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"files_toplevel()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":71,"source":"# File lib/shomen/rdoc.rb, line 71\n  def files_toplevel\n    @files_toplevel ||= (\n      @files_rdoc.select{ |f| f.parser == RDoc::Parser::Simple }\n    )\n  end","language":"ruby"},"RDoc::Parser::C#find_class_comment":{"!":"method","declarations":["instance","public"],"path":"RDoc::Parser::C#find_class_comment","name":"find_class_comment","namespace":"RDoc::Parser::C","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"find_class_comment(class_name, class_meth)","arguments":[{"name":"class_name"},{"name":"class_meth"}]}],"returns":[],"file":"/lib/shomen/rdoc/extensions.rb","line":120,"source":"# File lib/shomen/rdoc/extensions.rb, line 120\n    def find_class_comment(class_name, class_meth)\n      comment = nil\n      if @content =~ %{((?>/\\*.*?\\*/\\s+))\n                     (static\\s+)?void\\s+Init_#{class_name}\\s*(?:_\\(\\s*)?\\(\\s*(?:void\\s*)\\)}mi then\n        comment = $1\n      elsif @content =~ %{Document-(?:class|module):\\s#{class_name}\\s*?(?:<\\s+[:,\\w]+)?\\n((?>.*?\\*/))}\n        comment = $1\n      else\n        if @content =~ /rb_define_(class|module)/ then\n          class_name = class_name.split(\"::\").last\n          comments = []\n          @content.split(/(\\/\\*.*?\\*\\/)\\s*?\\n/).each_with_index do |chunk, index|\n            comments[index] = chunk\n            if chunk =~ /rb_define_(class|module).*?\"(#{class_name})\"/ then\n              comment = comments[index-1]\n              break\n            end\n          end\n        end\n      end\n      class_meth.comment = mangle_comment(comment) if comment\n    end","language":"ruby"},"Shomen::Metadata#gemspec":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#gemspec","name":"gemspec","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"gemspec()","arguments":[]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":48,"source":"# File lib/shomen/metadata.rb, line 48\n    def gemspec\n      file = Dir[File.join(PWD, '{,*}.gemspec')].first\n      return nil unless File.exist?(file)\n      file\n    end","language":"ruby"},"RDoc::Generator::Shomen#generate":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#generate","name":"generate","namespace":"RDoc::Generator::Shomen","comment":"Build the initial indices and output objects\nbased on an array of top level objects containing\nthe extracted information.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate(files)","arguments":[{"name":"files"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":117,"source":"# File lib/shomen/rdoc.rb, line 117\n  def generate(files)\n    @files_rdoc = files.sort\n\n    @table = {}\n\n    generate_metadata\n    generate_constants\n    generate_classes\n    #generate_attributes\n    generate_methods\n    generate_documents\n    generate_scripts   # must be last b/c it depends on the others\n\n    # TODO: method accessor fields need to be handled\n\n    # THINK: Internal referencing model, YAML and JSYNC ?\n    #ref_table = reference_table(@table)\n\n  #rescue StandardError => err\n  #  debug_msg \"%s: %s\\n  %s\" % [ err.class.name, err.message, err.backtrace.join(\"\\n  \") ]\n  #  raise err\n  end","language":"ruby"},"Shomen::YardAdaptor#generate":{"!":"method","declarations":["instance","public"],"path":"Shomen::YardAdaptor#generate","name":"generate","namespace":"Shomen::YardAdaptor","comment":"Generate the shomen data structure.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate()","arguments":[]}],"returns":[],"file":"/lib/shomen/yard.rb","line":23,"source":"# File lib/shomen/yard.rb, line 23\n    def generate\n      if not File.exist?(@db)\n        $stderr.puts \"ERROR: YARD database not found -- '#{@db}`.\"\n        exit -1\n      end\n\n      @table = {}\n\n      generate_metadata\n\n      @registry = YARD::Registry.load!(@db)\n      @registry.each do |object|\n        case object.type\n        when :constant\n          generate_constant(object)\n        when :class, :module\n          generate_class(object)\n          # TODO: is this needed?\n          object.constants.each do |c|\n            generate_constant(c)\n          end\n        #when :module\n        #  generate_module(object)\n        #  # TODO: is this needed?\n        #  object.constants.each do |c|\n        #    generate_constant(c)\n        #  end\n        when :method\n          generate_method(object)\n        else\n          $stderr.puts \"What is an #{object.type}? Ignored!\"\n        end\n      end\n\n      # TODO: Are c/c++ sourse files working okay?\n      # TODO: Add a generator for non-ruby script (e.g. .js)?\n      collect_files.each do |file|\n        case File.extname(file)\n        when '.rb', '.rbx', '.c', '.cpp'\n          generate_script(file)\n        when '.rdoc', '.md', '.markdown', '.txt'\n          generate_document(file)\n        else\n          generate_document(file)\n        end\n      end\n    end","language":"ruby"},"RDoc::Generator::Shomen#generate_attributes":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_attributes","name":"generate_attributes","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_attributes(table)","arguments":[{"name":"table"}]}],"returns":[],"file":"/lib/shomen/rdoc.0.rb","line":435,"source":"# File lib/shomen/rdoc.0.rb, line 435\n  def generate_attributes(table)\n    debug_msg \"Generating attributes documentation:\"\n    attributes_all.each do |m|\n      debug_msg \"%s\" % [m.full_name]\n\n      code       = m.source_code_raw\n      file, line = m.source_code_locationModel::Method\n\n      full_name = method_name(m)\n\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      #model_class = m.singleton ? Shomen::Model::Function : Shomen::Model::Method\n      model_class = Shomen::Model::Attribute\n\n      table[full_name] = model_class.new(\n        'key'          => full_name,\n        'name'         => m.name,\n        'namespace'    => m.parent_name,\n        'comment'      => m.comment,\n        'access'       => m.visibility.to_s,\n        'rw'           => m.rw,  # TODO: better name ?\n        'singleton'    => m.singleton,\n        'aliases'      => m.aliases.map{ |a| method_name(a) },\n        'alias_for'    => method_name(m.is_alias_for),\n        'image'        => m.params,\n        'arguments'    => [],\n        'parameters'   => [],\n        'block'        => m.block_params, # TODO: what is block?\n        'interface'    => m.arglists,\n        'returns'      => [],\n        'file'         => file,\n        'line'         => line,\n        'source'       => code\n      ).to_h\n    end\n    return table\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_classes":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_classes","name":"generate_classes","namespace":"RDoc::Generator::Shomen","comment":"Add classes (and modules) to table.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_classes()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":194,"source":"# File lib/shomen/rdoc.rb, line 194\n  def generate_classes\n    debug_msg \"Generating class/module documentation:\"\n\n    classes.each do |rdoc_class|\n      debug_msg \"%s (%s)\" % [ rdoc_class.full_name, rdoc_class.path ]\n\n      if rdoc_class.type=='class'\n        model = Shomen::Model::Class.new\n      else\n        model = Shomen::Model::Module.new\n      end\n\n      model.path             = rdoc_class.full_name\n      model.name             = rdoc_class.name\n      model.namespace        = rdoc_class.full_name.split('::')[0...-1].join('::')\n      model.includes         = rdoc_class.includes.map{ |x| x.name }  # FIXME: How to \"lookup\" full name?\n      model.extensions       = []                                     # TODO:  How to get extensions?\n      model.comment          = rdoc_class.comment\n      model.format           = 'rdoc'\n      model.constants        = rdoc_class.constants.map{ |x| complete_name(x.name, rdoc_class.full_name) }\n      model.modules          = rdoc_class.modules.map{ |x| complete_name(x.name, rdoc_class.full_name) }\n      model.classes          = rdoc_class.classes.map{ |x| complete_name(x.name, rdoc_class.full_name) }\n      model.methods          = rdoc_class.method_list.map{ |m| method_name(m) }.uniq\n      model.accessors        = rdoc_class.attributes.map{ |a| method_name(a) }.uniq  #+ \":#{a.rw}\" }.uniq\n      model.files            = rdoc_class.in_files.map{ |x| \"/#{x.full_name}\" }\n\n      if rdoc_class.type == 'class'\n        # HACK: No idea why RDoc is returning some weird superclass:\n        #   <RDoc::NormalClass:0xd924d4 class Object < BasicObject includes: []\n        #     attributes: [] methods: [#<RDoc::AnyMethod:0xd92b8c Object#fileutils\n        #     (public)>] aliases: []>\n        # Maybe it has something to do with #fileutils?\n        model.superclass = (\n          if String === rdoc_class.superclass\n            rdoc_class.superclass.to_s \n          else\n            rdoc_class.superclass.name\n          end\n        )\n      end\n\n      @table[model.path] = model.to_h\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_constants":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_constants","name":"generate_constants","namespace":"RDoc::Generator::Shomen","comment":"Add constants to table.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_constants()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":176,"source":"# File lib/shomen/rdoc.rb, line 176\n  def generate_constants\n    debug_msg \"Generating constant documentation:\"\n    constants_all.each do |rdoc|\n      model = Shomen::Model::Constant.new\n\n      model.path      = rdoc.parent.full_name + '::' + rdoc.name\n      model.name      = rdoc.name\n      model.namespace = rdoc.parent.full_name\n      model.comment   = rdoc.comment\n      model.format    = 'rdoc'\n      model.value     = rdoc.value\n      model.files     = [\"/#{rdoc.file.full_name}\"]\n\n      @table[model.path] = model.to_h\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_documents":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_documents","name":"generate_documents","namespace":"RDoc::Generator::Shomen","comment":"  #\n  def generate_attributes\n#$stderr.puts \"HERE!\"\n#$stderr.puts attributes_all.inspect\n#exit\n    debug_msg \"Generating attributes documentation:\"\n    attributes_all.each do |rdoc_attribute|\n      debug_msg \"%s\" % [rdoc_attribute.full_name]\n\n      adapter = Shomen::RDoc::MethodAdapter.new(rdoc_attribute)\n      data    = Shomen::Model::Method.new(adapter).to_h\n\n      @table[data['path']] = data\n\n      #code       = m.source_code_raw\n      #file, line = m.source_code_location\n\n      #full_name = method_name(m)\n\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      #model_class = m.singleton ? Shomen::Model::Function : Shomen::Model::Method\n      #model_class = Shomen::Model::Attribute\n\n      #@table[full_name] = model_class.new(\n      #  'path'         => full_name,\n      #  'name'         => m.name,\n      #  'namespace'    => m.parent_name,\n      #  'comment'      => m.comment,\n      #  'access'       => m.visibility.to_s,\n      #  'rw'           => m.rw,  # TODO: better name ?\n      #  'singleton'    => m.singleton,\n      #  'aliases'      => m.aliases.map{ |a| method_name(a) },\n      #  'alias_for'    => method_name(m.is_alias_for),\n      #  'image'        => m.params,\n      #  'arguments'    => [],\n      #  'parameters'   => [],\n      #  'block'        => m.block_params, # TODO: what is block?\n      #  'interface'    => m.arglists,\n      #  'returns'      => [],\n      #  'file'         => file,\n      #  'line'         => line,\n      #  'source'       => code\n      #).to_h\n    end\n  end\n\n# Generate entries for information files, e.g. `README.rdoc`.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_documents()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":392,"source":"# File lib/shomen/rdoc.rb, line 392\n  def generate_documents\n    files_toplevel.each do |rdoc_document|\n      absolute_path = File.join(path_base, rdoc_document.full_name)\n\n      model = Shomen::Model::Document.new\n\n      model.path   = rdoc_document.full_name\n      model.name   = File.basename(absolute_path)\n      model.mtime  = File.mtime(absolute_path)\n      model.text   = File.read(absolute_path) #file.comment\n      model.format = mime_type(absolute_path)\n\n      @table['/'+model.path] = model.to_h\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_files":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_files","name":"generate_files","namespace":"RDoc::Generator::Shomen","comment":"Generate entries for whole information files, e.g. README files.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_files(table)","arguments":[{"name":"table"}]}],"returns":[],"file":"/lib/shomen/rdoc.0.rb","line":585,"source":"# File lib/shomen/rdoc.0.rb, line 585\n  def generate_files(table)\n    files_toplevel.each do |rdoc_file|\n      adapter = Shomen::RDoc::DocumentAdapter.new(rdoc_file)\n      data    = Shomen::Model::Document.new(adapter).to_h\n\n      @table['/'+data['path']] = data\n\n      #abspath = File.join(path_base, file.full_name)\n      #table[file.full_name] = Shomen::Model::Document.new(\n      #  \"key\"    => file.full_name,\n      #  \"name\"   => File.basename(file.full_name),\n      #  \"parent\" => File.dirname(file.full_name),\n      #  \"path\"   => file.full_name,\n      #  \"mtime\"  => File.mtime(abspath),\n      #  \"text\"   => File.read(abspath) #file.comment\n      #).to_h\n      #table['/'+file.full_name] = data\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_metadata":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_metadata","name":"generate_metadata","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_metadata()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":170,"source":"# File lib/shomen/rdoc.rb, line 170\n  def generate_metadata\n    metadata = Shomen::Metadata.new\n    @table['(metadata)'] = metadata.to_h\n  end","language":"ruby"},"Shomen::Metadata#generate_metadata":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#generate_metadata","name":"generate_metadata","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_metadata(table)","arguments":[{"name":"table"}]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":76,"source":"# File lib/shomen/metadata.rb, line 76\n  def generate_metadata(table)\n    begin\n      #require 'pom/project'\n      generate_metadata_from_spec(table)\n    rescue Exception => error\n      puts error\n      begin\n        if spec = Dir['*.gemspec'].first\n          require 'rubygems/specification'\n          generate_metadata_from_gemspec(table)\n        end\n      rescue Exception\n        debug_msg \"Could not find any meatadata.\"\n      end\n    end\n  end","language":"ruby"},"Shomen::Metadata#generate_metadata_from_gemspec":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#generate_metadata_from_gemspec","name":"generate_metadata_from_gemspec","namespace":"Shomen::Metadata","comment":"Metadata follows the .ruby specification.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_metadata_from_gemspec(table)","arguments":[{"name":"table"}]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":132,"source":"# File lib/shomen/metadata.rb, line 132\n  def generate_metadata_from_gemspec(table)\n    file = Dir[path_base + GEMSPEC_GLOB].first\n    spec = RubyGems::Specification.new(file)  #?\n    table['(metadata)'] = {\n      \"!\"           => \"metadata\",\n      \"key\"         => \"(metadata)\",\n      \"name\"        => spec.name,\n      \"title\"       => spec.name.upcase,\n      \"version\"     => spec.version.to_s,\n      \"summary\"     => spec.summary,\n      \"description\" => spec.description,\n      \"contact\"     => spec.email,\n      \"resources\"   => { \"homepage\" => spec.homepage },\n      \"markup\"      => 'rdoc'\n    }\n  end","language":"ruby"},"Shomen::Metadata#generate_metadata_from_spec":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#generate_metadata_from_spec","name":"generate_metadata_from_spec","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_metadata_from_spec(table)","arguments":[{"name":"table"}]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":97,"source":"# File lib/shomen/metadata.rb, line 97\n  def generate_metadata_from_spec(table)\n    file = Dir[path_base + SPEC_GLOB].first\n    data = YAML.load(File.new(file))\n    table['(metadata)'] = {\n      \"!\"           => \"metadata\",\n      \"name\"        => data['name'],\n      \"version\"     => data['version'],\n      \"title\"       => data['title'],\n      \"summary\"     => data['summary'],\n      \"description\" => data['description'],\n      \"contact\"     => data['contact'],\n      \"resources\"   => data['resources'],\n      \"markup\"      => 'rdoc'\n    }\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_methods":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_methods","name":"generate_methods","namespace":"RDoc::Generator::Shomen","comment":"Transform RDoc methods to Shomen model and add to table.\n\nTODO: How to get literal interface separate from call-sequnces?","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_methods()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":242,"source":"# File lib/shomen/rdoc.rb, line 242\n  def generate_methods\n    debug_msg \"Generating method documentation:\"\n\n    list = methods_all + attributes_all\n\n    list.each do |rdoc_method|\n      #debug_msg \"%s\" % [rdoc_method.full_name]\n\n      #full_name  = method_name(m)\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      model = Shomen::Model::Method.new\n\n      model.path        = method_name(rdoc_method)\n      model.name        = rdoc_method.name\n      model.namespace   = rdoc_method.parent_name\n      model.comment     = rdoc_method.comment\n      model.format      = 'rdoc'\n      model.aliases     = rdoc_method.aliases.map{ |a| method_name(a) }\n      model.alias_for   = method_name(rdoc_method.is_alias_for)\n      model.singleton   = rdoc_method.singleton\n\n      model.declarations << rdoc_method.type.to_s #singleton ? 'class' : 'instance'\n      model.declarations << rdoc_method.visibility.to_s\n\n      model.interfaces = []\n      if rdoc_method.call_seq\n        rdoc_method.call_seq.split(\"\\n\").each do |cs|\n          model.interfaces << parse_interface(cs)\n        end\n      end\n      model.interfaces << parse_interface(\"#{rdoc_method.name}#{rdoc_method.params}\")\n\n      model.returns    = []  # RDoc doesn't support specifying return values\n      model.file       = '/'+rdoc_method.source_code_location.first\n      model.line       = rdoc_method.source_code_location.last.to_i\n      model.source     = rdoc_method.source_code_raw\n\n      if rdoc_method.respond_to?(:c_function)\n        model.language = rdoc_method.c_function ? 'c' : 'ruby'\n      else\n        model.language = 'ruby'\n      end\n\n      @table[model.path] = model.to_h\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#generate_scripts":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#generate_scripts","name":"generate_scripts","namespace":"RDoc::Generator::Shomen","comment":"Generate script entries.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"generate_scripts()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":411,"source":"# File lib/shomen/rdoc.rb, line 411\n  def generate_scripts\n    #debug_msg \"Generating file documentation in #{path_output_relative}:\"\n    #templatefile = self.path_template + 'file.rhtml'\n\n    files.each do |rdoc_file|\n      debug_msg \"%s\" % [rdoc_file.full_name]\n\n      absolute_path = File.join(path_base, rdoc_file.full_name)\n      #rel_prefix  = self.path_output.relative_path_from(outfile.dirname)\n\n      model = Shomen::Model::Script.new\n\n      model.path      = rdoc_file.full_name\n      model.name      = File.basename(rdoc_file.full_name)\n      model.mtime     = File.mtime(absolute_path)\n      model.source    = File.read(absolute_path) #file.comment\n      model.language  = mime_type(absolute_path)\n      #model.header   =\n      #model.footer   =\n      model.requires  = rdoc_file.requires.map{ |r| r.name }\n      model.constants = rdoc_file.constants.map{ |c| c.full_name }\n\n      # note that this utilizes the table we are building\n      # so it needs to be the last thing done.\n      @table.each do |k, h|\n        case h['!']\n        when 'module'\n          model.modules ||= []\n          model.modules << k if h['files'].include?(rdoc_file.full_name)\n        when 'class'\n          model.classes ||= []\n          model.classes << k if h['files'].include?(rdoc_file.full_name)\n        when 'method'\n          model.methods ||= []\n          model.methods << k if h['file'] == rdoc_file.full_name\n        when 'class-method'\n          model.class_methods ||= []\n          model.class_methods << k if h['file'] == rdoc_file.full_name\n        end\n      end\n\n      @table['/'+model.path] = model.to_h\n    end\n  end","language":"ruby"},"Shomen::Model::Method#interfaces=":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#interfaces=","name":"interfaces=","namespace":"Shomen::Model::Method","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"interfaces=(array)","arguments":[{"name":"array"}]}],"returns":[],"file":"/lib/shomen/model/method.rb","line":55,"source":"# File lib/shomen/model/method.rb, line 55\n      def interfaces=(array)\n        self['interfaces'] = (\n          array.map do |settings|\n            case settings\n            when Interface\n              settings\n            else\n              Interface.new(settings)\n            end\n          end\n        )\n      end","language":"ruby"},"RDoc::Generator::Shomen#method_name":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#method_name","name":"method_name","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"method_name(method)","arguments":[{"name":"method"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":491,"source":"# File lib/shomen/rdoc.rb, line 491\n  def method_name(method)\n    return nil if method.nil?\n    if method.singleton\n      i = method.full_name.rindex('::')     \n      method.full_name[0...i] + '.' + method.full_name[i+2..-1]\n    else\n      method.full_name\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#methods_all":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#methods_all","name":"methods_all","namespace":"RDoc::Generator::Shomen","comment":"List of all methods in all classes and modules.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"methods_all()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":84,"source":"# File lib/shomen/rdoc.rb, line 84\n  def methods_all\n    @methods_all ||= classes.map{ |m| m.method_list }.flatten.sort\n  end","language":"ruby"},"RDoc::Generator::Shomen#mime_type":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#mime_type","name":"mime_type","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"mime_type(path)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":502,"source":"# File lib/shomen/rdoc.rb, line 502\n  def mime_type(path)\n    case File.extname(path)\n    when '.rb', '.rbx' then 'text/ruby'\n    when '.c' then 'text/c-source'\n    when '.rdoc' then 'text/rdoc'\n    when '.md', '.markdown' then 'text/markdown'\n    else 'text/plain'\n    end\n  end","language":"ruby"},"Shomen::CLI::Abstract#option_debug":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#option_debug","name":"option_debug","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_debug(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":53,"source":"# File lib/shomen/cli/abstract.rb, line 53\n      def option_debug(parser, options)\n        parser.on_tail('-D', '--debug', 'run with $DEBUG set to true') do\n          $DEBUG = true\n        end\n      end","language":"ruby"},"Shomen::CLI::Abstract#option_force":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#option_force","name":"option_force","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_force(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":46,"source":"# File lib/shomen/cli/abstract.rb, line 46\n      def option_force(parser, options)\n        parser.on('-f', '--force') do\n          options[:force] = true\n        end\n      end","language":"ruby"},"Shomen::CLI::RDocCommand#option_format":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::RDocCommand#option_format","name":"option_format","namespace":"Shomen::CLI::RDocCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_format(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/rdoc.rb","line":109,"source":"# File lib/shomen/cli/rdoc.rb, line 109\n      def option_format(parser, options)\n        parser.on('-f', '--format NAME') do |format|\n          options[:format] = format.to_sym\n        end\n      end","language":"ruby"},"Shomen::CLI::Abstract#option_help":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#option_help","name":"option_help","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_help(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":67,"source":"# File lib/shomen/cli/abstract.rb, line 67\n      def option_help(parser, options)\n        parser.on_tail('--help') do\n          puts opt\n          exit 0\n        end\n      end","language":"ruby"},"Shomen::CLI::Abstract#option_json":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#option_json","name":"option_json","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_json(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":39,"source":"# File lib/shomen/cli/abstract.rb, line 39\n      def option_json(parser, options)\n        parser.on('-j', '--json', 'output JSON instead of YAML (default)') do\n          options[:format] = :json\n        end\n      end","language":"ruby"},"Shomen::CLI::RDocCommand#option_main":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::RDocCommand#option_main","name":"option_main","namespace":"Shomen::CLI::RDocCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_main(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/rdoc.rb","line":116,"source":"# File lib/shomen/cli/rdoc.rb, line 116\n      def option_main(parser, options)\n        parser.on('-m', '--main FILE') do |file|\n          options[:main] = file\n        end\n      end","language":"ruby"},"Shomen::CLI::RDocCommand#option_visibility":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::RDocCommand#option_visibility","name":"option_visibility","namespace":"Shomen::CLI::RDocCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_visibility(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/rdoc.rb","line":92,"source":"# File lib/shomen/cli/rdoc.rb, line 92\n      def option_visibility(parser, options)\n        parser.on('--private', 'include public, protected and private methods') do\n          options[:visibility] = :private\n        end\n        parser.on('--protected', 'include public and protected methods') do\n          options[:visibility] = :protected\n        end\n      end","language":"ruby"},"Shomen::CLI::Abstract#option_warn":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#option_warn","name":"option_warn","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_warn(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":60,"source":"# File lib/shomen/cli/abstract.rb, line 60\n      def option_warn(parser, options)\n        parser.on_tail('-W', '--warn', 'run with $VERBOSE set to true') do\n          $VERBOSE = true\n        end\n      end","language":"ruby"},"Shomen::CLI::Abstract#option_yaml":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#option_yaml","name":"option_yaml","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"option_yaml(parser, options)","arguments":[{"name":"parser"},{"name":"options"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":32,"source":"# File lib/shomen/cli/abstract.rb, line 32\n      def option_yaml(parser, options)\n        parser.on('-y', '--yaml', 'output YAML instead of JSON') do\n          options[:format] = :yaml\n        end\n      end","language":"ruby"},"Shomen::CLI::Abstract#parse":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#parse","name":"parse","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"parse(argv, *choices)","arguments":[{"name":"argv"},{"name":"*choices"}]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":15,"source":"# File lib/shomen/cli/abstract.rb, line 15\n      def parse(argv, *choices)\n        options = (Hash === choices.last ? choices.pop : {})\n        parser  = OptionParser.new\n\n        choices.each do |choice|\n          send(\"option_#{choice}\", parser, options)\n        end\n        option_debug(parser, options)\n        option_warn(parser, options)\n        option_help(parser, options)\n\n        parser.parse!(argv)\n\n        return options\n      end","language":"ruby"},"RDoc::Generator::Shomen#path_output_relative":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#path_output_relative","name":"path_output_relative","namespace":"RDoc::Generator::Shomen","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"path_output_relative(path=nil)","arguments":[{"name":"path","default":"nil"}]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":161,"source":"# File lib/shomen/rdoc.rb, line 161\n  def path_output_relative(path=nil)\n    if path\n      path.to_s.sub(path_base.to_s+'/', '')\n    else\n      @path_output_relative ||= path_output.to_s.sub(path_base.to_s+'/', '')\n    end\n  end","language":"ruby"},"RDoc::Generator::Shomen#ref_item":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#ref_item","name":"ref_item","namespace":"RDoc::Generator::Shomen","comment":"  # Loop through table and convert all named references into bonofied object\n  # references.\n  def reference_table(table)\n    debug_msg \"== Generating Reference Table\"\n    new_table = {}\n    table.each do |key, entry|\n      debug_msg \"%s\" % [key]\n      data = entry.dup\n      new_table[key] = data\n      case data['!']\n      when 'script'\n        data[\"constants\"]  = ref_list(data[\"constants\"])\n        data[\"modules\"]    = ref_list(data[\"modules\"])\n        data[\"classes\"]    = ref_list(data[\"classes\"])\n        data[\"functions\"]  = ref_list(data[\"functions\"])\n        data[\"methods\"]    = ref_list(data[\"methods\"])\n      when 'file'\n      when 'constant'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n      when 'module', 'class'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n        data[\"includes\"]   = ref_list(data[\"includes\"])\n        #data[\"extended\"]  = ref_list(data[\"extended\"])\n        data[\"constants\"]  = ref_list(data[\"constants\"])\n        data[\"modules\"]    = ref_list(data[\"modules\"])\n        data[\"classes\"]    = ref_list(data[\"classes\"])\n        data[\"functions\"]  = ref_list(data[\"functions\"])\n        data[\"methods\"]    = ref_list(data[\"methods\"])\n        data[\"files\"]      = ref_list(data[\"files\"])\n        data[\"superclass\"] = ref_item(data[\"superclass\"]) if data.key?(\"superclass\")\n      when 'method', 'function'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n        data[\"file\"]       = ref_item(data[\"file\"])\n      end\n    end\n    new_table\n  end\n\n# Given a key, return the matching table item. If not found return the key.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"ref_item(key)","arguments":[{"name":"key"}]}],"returns":[],"file":"/lib/shomen/rdoc.0.rb","line":258,"source":"# File lib/shomen/rdoc.0.rb, line 258\n  def ref_item(key)\n    @table[key] || key\n  end","language":"ruby"},"RDoc::Generator::Shomen#ref_list":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#ref_list","name":"ref_list","namespace":"RDoc::Generator::Shomen","comment":"Given a list of keys, return the matching table items.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"ref_list(keys)","arguments":[{"name":"keys"}]}],"returns":[],"file":"/lib/shomen/rdoc.0.rb","line":263,"source":"# File lib/shomen/rdoc.0.rb, line 263\n  def ref_list(keys)\n    #keys.map{ |k| @table[k] || k }\n    keys.map{ |k| @table[k] || nil }.compact\n  end","language":"ruby"},"Shomen::CLI::Abstract#root?":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::Abstract#root?","name":"root?","namespace":"Shomen::CLI::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"root?()","arguments":[]}],"returns":[],"file":"/lib/shomen/cli/abstract.rb","line":75,"source":"# File lib/shomen/cli/abstract.rb, line 75\n      def root?\n        root = false\n        root = true if File.exist?('.ruby')\n        root = true if File.exist?('.yardoc')\n        root = true if File.exist?('.git')\n        root = true if File.exist?('.hg')\n        root\n      end","language":"ruby"},"Shomen::CLI::YARDCommand#run":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::YARDCommand#run","name":"run","namespace":"Shomen::CLI::YARDCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"run(argv)","arguments":[{"name":"argv"}]}],"returns":[],"file":"/lib/shomen/cli/yard.rb","line":24,"source":"# File lib/shomen/cli/yard.rb, line 24\n      def run(argv)\n        require 'shomen/yard'\n\n        force = argv.delete('--force')\n\n        if !(force or root?)\n          $stderr.puts \"ERROR: Not a project directory. Use --force to override.\"\n          exit -1\n        end\n\n        format = (\n          if i = argv.index('--format') || argv.index('-f')\n            argv[i+1]\n            argv.delete_at(i)\n            argv.delete_at(i)\n          else\n            'json'\n          end\n        )\n\n        case format\n        when 'json', 'yaml'\n        else\n          $stderr.puts \"ERROR: Format must be 'yaml` or 'json`.\"\n          exit -1\n        end\n\n        argv.unshift('-n')  # do not generate yard documentation\n        argv.unshift('-q')  # supress yard's usual output\n\n        YARD::Registry.clear  # clear the registry in memory to remove any previous runs\n\n        yard = YARD::CLI::Yardoc.new\n        yard.run(*argv)\n\n        files    = yard.options[:files].map(&:filename) + yard.files\n        database = yard.options[:db]\n\n        options = {}\n        options[:format] = format\n        options[:files]  = files\n        options[:db]     = database\n\n        #options = parse(argv, :yaml, :clear, :db, :yardopts, :force, defaults)\n\n        yard = Shomen::YardAdaptor.new(options)\n        yard.generate\n\n        case format\n        when 'yaml'\n          $stdout.puts(yard.table.to_yaml)\n        else\n          $stdout.puts(yard.table.to_json)\n        end\n      end","language":"ruby"},"Shomen::CLI::RDocCommand#run":{"!":"method","declarations":["instance","public"],"path":"Shomen::CLI::RDocCommand#run","name":"run","namespace":"Shomen::CLI::RDocCommand","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"run(argv)","arguments":[{"name":"argv"}]}],"returns":[],"file":"/lib/shomen/cli/rdoc.rb","line":28,"source":"# File lib/shomen/cli/rdoc.rb, line 28\n      def run(argv)\n        require 'shomen/rdoc'\n\n        defaults = {}\n        defaults[:format]  = :json\n        defaults[:force]   = false\n\n        options = parse(argv, :format, :force, :visibility, defaults)\n\n        if !options[:force] && !root?\n          $stderr.puts \"Not a project directory. Use --force to override.\"\n          exit -1\n        end\n\n        if argv.empty?\n          if File.exist?('.document')\n            files = File.read('.document').split(\"\\n\")\n            files.reject!{ |f| f.strip == '' }\n          else\n            files = ['lib']\n          end\n        else\n          files = argv\n        end\n\n        tmpdir     = File.join(Dir.tmpdir, 'shomen-rdoc')\n        main       = options[:main] || Dir.glob('{README.*,README}').first\n        visibility = options[:visibility].to_s\n\n        # TODO: Any way to supress the cretion of the time stamp altogether?\n        # Options#update_output_dir for instance?\n\n        # TODO: Using the ::RDoc::Options doesn't seem to work.\n        # It complains about a template being nil in `rdoc/options.rb:760`.\n\n        #rdoc_options = ::RDoc::Options.new\n        #rdoc_options.generator = 'shomen'\n        #rdoc_options.main_page = Dir.glob('README*').first\n        ##rdoc_options.template  = 'shomen'\n        ##rdoc_options.template_dir = File.dirname(__FILE__)\n        #rdoc_options.op_dir    = 'tmp/rdoc'  # '/dev/null'\n        #rdoc_options.files     = files\n\n        rdoc_options  = []\n        rdoc_options += ['-q']\n        #rdoc_options += ['-t', title]\n        rdoc_options += ['-f', 'shomen']\n        rdoc_options += ['-m', main] if main\n        rdoc_options += ['-V', visibility]\n        rdoc_options += ['-o', tmpdir]  # '/dev/null'\n        rdoc_options += files\n\n        rdoc = ::RDoc::RDoc.new\n        rdoc.document(rdoc_options)\n\n        case options[:format]\n        when :yaml\n          $stdout.puts(rdoc.generator.shomen.to_yaml)\n        else\n          $stdout.puts(JSON.generate(rdoc.generator.shomen))\n        end\n      end","language":"ruby"},"RDoc::Generator::Shomen#shomen":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#shomen","name":"shomen","namespace":"RDoc::Generator::Shomen","comment":"TODO: Rename ?","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"shomen()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc.rb","line":110,"source":"# File lib/shomen/rdoc.rb, line 110\n  def shomen\n    @table || {}\n  end","language":"ruby"},"Shomen::Metadata#size":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#size","name":"size","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"size()","arguments":[]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":60,"source":"# File lib/shomen/metadata.rb, line 60\n    def size\n      @data.size\n    end","language":"ruby"},"RDoc::SourceCodeAccess#source_code_location":{"!":"method","declarations":["instance","public"],"path":"RDoc::SourceCodeAccess#source_code_location","name":"source_code_location","namespace":"RDoc::SourceCodeAccess","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"source_code_location()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc/extensions.rb","line":64,"source":"# File lib/shomen/rdoc/extensions.rb, line 64\n  def source_code_location\n    src = source_code_raw\n    if md = /File (.*?), line (\\d+)/.match(src)\n      file = md[1]\n      line = md[2]\n    else\n      file = \"(unknown)\"\n      line = 0\n    end\n    return file, line\n  end","language":"ruby"},"RDoc::SourceCodeAccess#source_code_raw":{"!":"method","declarations":["instance","public"],"path":"RDoc::SourceCodeAccess#source_code_raw","name":"source_code_raw","namespace":"RDoc::SourceCodeAccess","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"source_code_raw()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc/extensions.rb","line":52,"source":"# File lib/shomen/rdoc/extensions.rb, line 52\n  def source_code_raw\n    return '' unless @token_stream\n    src = \"\"\n    @token_stream.each do |t|\n      next unless t\n      src << t.text\n    end\n    #add_line_numbers(src)\n    src\n  end","language":"ruby"},"RDoc::TopLevel#to_h":{"!":"method","declarations":["instance","public"],"path":"RDoc::TopLevel#to_h","name":"to_h","namespace":"RDoc::TopLevel","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc/extensions.rb","line":3,"source":"# File lib/shomen/rdoc/extensions.rb, line 3\n  def to_h\n    {\n       :path     => path,\n       :name     => base_name,\n       :fullname => full_name,\n       :rootname => absolute_name,\n       :modified => last_modified,\n       :diagram  => diagram\n    }\n  end","language":"ruby"},"Shomen::Model::AbstractPrime#to_h":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::AbstractPrime#to_h","name":"to_h","namespace":"Shomen::Model::AbstractPrime","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":46,"source":"# File lib/shomen/model/abstract.rb, line 46\n      def to_h\n        t = {}\n        @table.each do |k,v|\n          if v.respond_to?(:to_h)\n            t[k] = v.to_h\n          else\n            t[k] = v\n          end\n        end\n        t\n      end","language":"ruby"},"Shomen::Model::Method#to_h":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#to_h","name":"to_h","namespace":"Shomen::Model::Method","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/method.rb","line":91,"source":"# File lib/shomen/model/method.rb, line 91\n      def to_h\n        h = super\n        h['!'] = 'method'\n        h['interfaces'] = (interfaces || []).map{ |s| s.to_h }\n        h\n      end","language":"ruby"},"Hash#to_h":{"!":"method","declarations":["instance","public"],"path":"Hash#to_h","name":"to_h","namespace":"Hash","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/shomen/core_ext/hash.rb","line":2,"source":"# File lib/shomen/core_ext/hash.rb, line 2\n  def to_h; self; end","language":"ruby"},"Shomen::Metadata#to_h":{"!":"method","declarations":["instance","public"],"path":"Shomen::Metadata#to_h","name":"to_h","namespace":"Shomen::Metadata","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/shomen/metadata.rb","line":70,"source":"# File lib/shomen/metadata.rb, line 70\n    def to_h\n      @data\n    end","language":"ruby"},"Shomen::Model::Abstract#type":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Abstract#type","name":"type","namespace":"Shomen::Model::Abstract","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/shomen/model/abstract.rb","line":76,"source":"# File lib/shomen/model/abstract.rb, line 76\n      def type\n        self['!']\n      end","language":"ruby"},"RDoc::ClassModule#with_documentation?":{"!":"method","declarations":["instance","public"],"path":"RDoc::ClassModule#with_documentation?","name":"with_documentation?","namespace":"RDoc::ClassModule","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"with_documentation?()","arguments":[]}],"returns":[],"file":"/lib/shomen/rdoc/extensions.rb","line":23,"source":"# File lib/shomen/rdoc/extensions.rb, line 23\n  def with_documentation?\n    document_self_or_methods || classes_and_modules.any?{ |c| c.with_documentation? }\n  end","language":"ruby"},"Shomen::Model::Module#accessors":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#accessors","name":"accessors","namespace":"Shomen::Model::Module","comment":"List of attributes.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"accessors","arguments":[{"name":"accessors"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#alias_for":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#alias_for","name":"alias_for","namespace":"Shomen::Model::Method","comment":"Aliases.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"alias_for","arguments":[{"name":"alias_for"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#aliases":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#aliases","name":"aliases","namespace":"Shomen::Model::Method","comment":"Aliases.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"aliases","arguments":[{"name":"aliases"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Interface#arguments":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Interface#arguments","name":"arguments","namespace":"Shomen::Model::Interface","comment":"Arguments breakdown.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"arguments","arguments":[{"name":"arguments"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Interface#block":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Interface#block","name":"block","namespace":"Shomen::Model::Interface","comment":"Block","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"block","arguments":[{"name":"block"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#class_methods":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#class_methods","name":"class_methods","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"class_methods","arguments":[{"name":"class_methods"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#classes":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#classes","name":"classes","namespace":"Shomen::Model::Module","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"classes","arguments":[{"name":"classes"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#classes":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#classes","name":"classes","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"classes","arguments":[{"name":"classes"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#comment":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#comment","name":"comment","namespace":"Shomen::Model::Module","comment":"Comment associated with module.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"comment","arguments":[{"name":"comment"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#comment":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#comment","name":"comment","namespace":"Shomen::Model::Method","comment":"Comment accompanying method definition.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"comment","arguments":[{"name":"comment"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Constant#comment":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Constant#comment","name":"comment","namespace":"Shomen::Model::Constant","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"comment","arguments":[{"name":"comment"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#constants":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#constants","name":"constants","namespace":"Shomen::Model::Module","comment":"Constants defined within this module.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"constants","arguments":[{"name":"constants"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#constants":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#constants","name":"constants","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"constants","arguments":[{"name":"constants"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#declarations":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#declarations","name":"declarations","namespace":"Shomen::Model::Method","comment":"Delarations is a list of keywords that designates characteristics\nabout a method. Common characteristics include `reader`, `writer`\nor `accessor` if the method is defined via an attr method; `public`\n`private` or `protected` given the methods visibility; and `class`\nor `instance` given the methods scope. Default designations are\nare impled if not specifically stated, such as `public` and `instance`.\n\nUsing a declarations list simplifies the Shomen data format by allowing\ndeclarations to be freely defined, rather than creating a field for each\npossible designation possible.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"declarations","arguments":[{"name":"declarations"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#dynamic":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#dynamic","name":"dynamic","namespace":"Shomen::Model::Method","comment":"Method generated dynamically?","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"dynamic","arguments":[{"name":"dynamic"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#extensions":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#extensions","name":"extensions","namespace":"Shomen::Model::Module","comment":"Metaclass mixins.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"extensions","arguments":[{"name":"extensions"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#file":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#file","name":"file","namespace":"Shomen::Model::Method","comment":"Filename.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"file","arguments":[{"name":"file"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#files":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#files","name":"files","namespace":"Shomen::Model::Module","comment":"The files in which the module is defined.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"files","arguments":[{"name":"files"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Constant#files":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Constant#files","name":"files","namespace":"Shomen::Model::Constant","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"files","arguments":[{"name":"files"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#footer":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#footer","name":"footer","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"footer","arguments":[{"name":"footer"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Document#format":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Document#format","name":"format","namespace":"Shomen::Model::Document","comment":"Format of comment (rdoc, markdown or plain).","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"format","arguments":[{"name":"format"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#format":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#format","name":"format","namespace":"Shomen::Model::Module","comment":"Format of comment (rdoc, markdown or plain).","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"format","arguments":[{"name":"format"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#format":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#format","name":"format","namespace":"Shomen::Model::Method","comment":"Format of comment (rdoc, markdown or plain).","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"format","arguments":[{"name":"format"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Constant#format":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Constant#format","name":"format","namespace":"Shomen::Model::Constant","comment":"Format of comment (rdoc, markdown or plain).","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"format","arguments":[{"name":"format"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#header":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#header","name":"header","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"header","arguments":[{"name":"header"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#includes":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#includes","name":"includes","namespace":"Shomen::Model::Module","comment":"Mixins.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"includes","arguments":[{"name":"includes"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#interfaces":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#interfaces","name":"interfaces","namespace":"Shomen::Model::Method","comment":"Breakdown of interfaces signature, arguments, parameters, block argument\nan return values.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"interfaces","arguments":[{"name":"interfaces"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#language":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#language","name":"language","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"language","arguments":[{"name":"language"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#language":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#language","name":"language","namespace":"Shomen::Model::Method","comment":"Source code language.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"language","arguments":[{"name":"language"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#line":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#line","name":"line","namespace":"Shomen::Model::Method","comment":"Line number.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"line","arguments":[{"name":"line"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#methods":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#methods","name":"methods","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"methods","arguments":[{"name":"methods"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#methods":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#methods","name":"methods","namespace":"Shomen::Model::Module","comment":"List of instance methods defined in the module.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"methods","arguments":[{"name":"methods"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#modules":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#modules","name":"modules","namespace":"Shomen::Model::Module","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"modules","arguments":[{"name":"modules"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#modules":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#modules","name":"modules","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"modules","arguments":[{"name":"modules"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#mtime":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#mtime","name":"mtime","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"mtime","arguments":[{"name":"mtime"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Document#mtime":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Document#mtime","name":"mtime","namespace":"Shomen::Model::Document","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"mtime","arguments":[{"name":"mtime"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Constant#name":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Constant#name","name":"name","namespace":"Shomen::Model::Constant","comment":"Constant's basename, must start with a capitalized letter.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"name","arguments":[{"name":"name"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#name":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#name","name":"name","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"name","arguments":[{"name":"name"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#name":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#name","name":"name","namespace":"Shomen::Model::Method","comment":"Method's name.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"name","arguments":[{"name":"name"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#name":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#name","name":"name","namespace":"Shomen::Model::Module","comment":"Method's name.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"name","arguments":[{"name":"name"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Document#name":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Document#name","name":"name","namespace":"Shomen::Model::Document","comment":"def key=(path)\n  path = '/' + path unless path[0,1] == '/'\n  super(path)\nend","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"name","arguments":[{"name":"name"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Module#namespace":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Module#namespace","name":"namespace","namespace":"Shomen::Model::Module","comment":"Namespace of module is the path of the class or module\ncontaining this module.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"namespace","arguments":[{"name":"namespace"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#namespace":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#namespace","name":"namespace","namespace":"Shomen::Model::Method","comment":"Method's namespace.","format":"rdoc","aliases":["Shomen::Model::Method#parent"],"alias_for":null,"singleton":false,"interfaces":[{"signature":"namespace","arguments":[{"name":"namespace"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Constant#namespace":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Constant#namespace","name":"namespace","namespace":"Shomen::Model::Constant","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"namespace","arguments":[{"name":"namespace"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"RDoc::Generator::Shomen#options":{"!":"method","declarations":["instance","public"],"path":"RDoc::Generator::Shomen#options","name":"options","namespace":"RDoc::Generator::Shomen","comment":"User options from the command line.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"options","arguments":[{"name":"options"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Interface#parameters":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Interface#parameters","name":"parameters","namespace":"Shomen::Model::Interface","comment":"Parameters breakdown.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"parameters","arguments":[{"name":"parameters"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#parent":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#parent","name":"parent","namespace":"Shomen::Model::Method","comment":"Method's namespace.","format":"rdoc","aliases":[],"alias_for":"Shomen::Model::Method#namespace","singleton":false,"interfaces":[{"signature":"parent","arguments":[{"name":"parent"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Abstract#path":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Abstract#path","name":"path","namespace":"Shomen::Model::Abstract","comment":"Full name.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"path","arguments":[{"name":"path"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#path":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#path","name":"path","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"path","arguments":[{"name":"path"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Document#path":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Document#path","name":"path","namespace":"Shomen::Model::Document","comment":"attr_accessor :parent","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"path","arguments":[{"name":"path"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"RDoc::Generator::Shomen#path_base":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#path_base","name":"path_base","namespace":"RDoc::Generator::Shomen","comment":"Current pathname.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"path_base","arguments":[{"name":"path_base"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"RDoc::Generator::Shomen#path_output":{"!":"method","declarations":["instance","protected"],"path":"RDoc::Generator::Shomen#path_output","name":"path_output","namespace":"RDoc::Generator::Shomen","comment":"The output path.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"path_output","arguments":[{"name":"path_output"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#requires":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#requires","name":"requires","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"requires","arguments":[{"name":"requires"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#returns":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#returns","name":"returns","namespace":"Shomen::Model::Method","comment":"List of possible returns types.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"returns","arguments":[{"name":"returns"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Interface#returns":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Interface#returns","name":"returns","namespace":"Shomen::Model::Interface","comment":"Return value.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"returns","arguments":[{"name":"returns"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Attribute#rw":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Attribute#rw","name":"rw","namespace":"Shomen::Model::Attribute","comment":"'R', 'W' or 'RW'","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"rw","arguments":[{"name":"rw"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Interface#signature":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Interface#signature","name":"signature","namespace":"Shomen::Model::Interface","comment":"The source code \"image\" of the method's inteface.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"signature","arguments":[{"name":"signature"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#singleton":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#singleton","name":"singleton","namespace":"Shomen::Model::Method","comment":"Singleton method `true` or `false/nil`.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"singleton","arguments":[{"name":"singleton"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Method#source":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Method#source","name":"source","namespace":"Shomen::Model::Method","comment":"Source code.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"source","arguments":[{"name":"source"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#source":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#source","name":"source","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":["Shomen::Model::Script#text","Shomen::Model::Script#text="],"alias_for":null,"singleton":false,"interfaces":[{"signature":"source","arguments":[{"name":"source"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Class#superclass":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Class#superclass","name":"superclass","namespace":"Shomen::Model::Class","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"superclass","arguments":[{"name":"superclass"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::YardAdaptor#table":{"!":"method","declarations":["instance","public"],"path":"Shomen::YardAdaptor#table","name":"table","namespace":"Shomen::YardAdaptor","comment":"The hash object that is used to store the generated \ndocumentation.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"table","arguments":[{"name":"table"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Abstract#tags":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Abstract#tags","name":"tags","namespace":"Shomen::Model::Abstract","comment":"Hash of label => description.","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"tags","arguments":[{"name":"tags"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Document#text":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Document#text","name":"text","namespace":"Shomen::Model::Document","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"text","arguments":[{"name":"text"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#text":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#text","name":"text","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":"Shomen::Model::Script#source","singleton":false,"interfaces":[{"signature":"text","arguments":[{"name":"text"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Script#text=":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Script#text=","name":"text=","namespace":"Shomen::Model::Script","comment":"","format":"rdoc","aliases":[],"alias_for":"Shomen::Model::Script#source","singleton":false,"interfaces":[{"signature":"text=","arguments":[{"name":"text"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"Shomen::Model::Constant#value":{"!":"method","declarations":["instance","public"],"path":"Shomen::Model::Constant#value","name":"value","namespace":"Shomen::Model::Constant","comment":"","format":"rdoc","aliases":[],"alias_for":null,"singleton":false,"interfaces":[{"signature":"value","arguments":[{"name":"value"}]}],"returns":[],"file":"/(unknown)","line":0,"source":"","language":"ruby"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":"2011-09-24 13:42:55 -0400","text":"= RELEASE HISTORY\n\n== 0.1.0 | 2010-09-27\n\nThis is the first release of the RDoc Shomen Adapter. At this stage it\nis of course likely that a few field changes will occur before the\nthe Shomen standard is finalizied, but it's is now in solid enough a\nstate to begin building documentation generators and webapps against.\n\nChanges:\n\n* Happy Release Day! You've been a long time in the making.\n\n","format":"text/rdoc"},"/NOTES.rdoc":{"!":"document","path":"NOTES.rdoc","name":"NOTES.rdoc","mtime":"2011-09-24 13:42:55 -0400","text":"= DEVELOPER NOTES\n\n== RDoc Dependency\n\nThough this could probably work with RDoc 2.4.2+, I have set the dependency to 2.5~.\n","format":"text/rdoc"},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":"2011-09-24 13:59:32 -0400","text":"= Shomen Documentation Specification\n\n{Website}[http://rubyworks.github.com/shomen]\n{User Manual}[http://github.com/rubyworks/shomen/wiki]\n\n\n== Description\n\nShomen is an intermediary documentation model suitable for documenting most\nobject-oriented programming languages, though designed first and foremost for\nRuby. The specification is a flat mapping, without internal referencing, suitable\nfor storage in both YAML and JSON formats.\n\n\n== Why?\n\nBy using a standard intermediary format, documentation parsers need only concern\nthemselves with a single output target. And documentation templates in turn only\nneed to concern themselves with a single input format to use regardless of the\nparsing system that was used to generate it.\n\n\n== Learn\n\nTo learn more about shomen please vist:\n\n* http://rubyworks.github.com/shomen\n* http://github.com/rubyworks/shomen/wiki\n\n\n== Usage\n\nShomen currently supports parsing via RDoc and YARD. Specify the parser to\nuse to the shomen command, e.g.\n\n  $ shomen rdoc lib [A-Z]*.* -m README.rdoc > site/doc.json\n\nIf a `.document` file exists, of course, the file globs can be omitted.\nFor yard it's basically the same deal.\n\n  $ shomen yard lib [A-Z]*.* -r README.rdoc > site/doc.json\n\nYARD will use `.yardopts` if it is present, so you genetally do not need to\nto specify any parameters, e.g.\n\n  $ shomen yard > site/doc.json\n\nNow that you have a Shomen documentation file for you project, you simply need \nto pair it up with a viewer. Currently that means using {HyperVisor}[http://github.com/rubyworks/hypervisor].\n\n\n\n== Copying\n\nCopyright (c) 2010 Thomas Sawyer\n\nShomen is distributed under the terms of the BSD-2-Clause license.\n\nSee COPYING.rdoc for license details.\n","format":"text/rdoc"},"/lib/shomen/cli.rb":{"!":"script","path":"lib/shomen/cli.rb","name":"cli.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  require 'optparse'\n  require 'yaml'\n  require 'json'\n\n  # Command line interface. (YARD oriented for now).\n  def self.cli(*argv)\n    case cmd = argv.shift\n    when 'server'\n      require 'shomen/server'\n    when 'yard'\n      require 'shomen/cli/yard'\n      CLI::YARDCommand.run(*argv)\n    when 'rdoc'\n      require 'shomen/cli/rdoc'\n      CLI::RDocCommand.run(*argv)\n    else\n      abort \"error: unrecognized command - #{cmd}\"\n    end\n  end\n\nend\n","language":"text/ruby","requires":["optparse","yaml","json","shomen/server","shomen/cli/yard","shomen/cli/rdoc"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/cli/abstract.rb":{"!":"script","path":"lib/shomen/cli/abstract.rb","name":"abstract.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module CLI\n\n    # Command line interface base class.\n    #\n    class Abstract\n\n      #\n      def self.run(*arg)\n        new.run(*argv)\n      end\n\n      #\n      def parse(argv, *choices)\n        options = (Hash === choices.last ? choices.pop : {})\n        parser  = OptionParser.new\n\n        choices.each do |choice|\n          send(\"option_#{choice}\", parser, options)\n        end\n        option_debug(parser, options)\n        option_warn(parser, options)\n        option_help(parser, options)\n\n        parser.parse!(argv)\n\n        return options\n      end\n\n      #\n      def option_yaml(parser, options)\n        parser.on('-y', '--yaml', 'output YAML instead of JSON') do\n          options[:format] = :yaml\n        end\n      end\n\n      #\n      def option_json(parser, options)\n        parser.on('-j', '--json', 'output JSON instead of YAML (default)') do\n          options[:format] = :json\n        end\n      end\n\n      #\n      def option_force(parser, options)\n        parser.on('-f', '--force') do\n          options[:force] = true\n        end\n      end\n\n      #\n      def option_debug(parser, options)\n        parser.on_tail('-D', '--debug', 'run with $DEBUG set to true') do\n          $DEBUG = true\n        end\n      end\n\n      #\n      def option_warn(parser, options)\n        parser.on_tail('-W', '--warn', 'run with $VERBOSE set to true') do\n          $VERBOSE = true\n        end\n      end\n\n      #\n      def option_help(parser, options)\n        parser.on_tail('--help') do\n          puts opt\n          exit 0\n        end\n      end\n\n      #\n      def root?\n        root = false\n        root = true if File.exist?('.ruby')\n        root = true if File.exist?('.yardoc')\n        root = true if File.exist?('.git')\n        root = true if File.exist?('.hg')\n        root\n      end\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":[],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/cli/rdoc.rb":{"!":"script","path":"lib/shomen/cli/rdoc.rb","name":"rdoc.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  begin; gem 'json'; rescue; end\n\n  require 'shomen/cli/abstract'\n  require 'tmpdir'\n  require 'json'\n\n  module CLI\n\n    # RDoc command line interface.\n    class RDocCommand < Abstract\n\n      #\n      def self.run(*argv)\n        new.run(argv)\n      end\n\n      # New RDoc command line interface.\n      def initialize\n        begin\n          gem 'rdoc'\n        rescue\n        end\n      end\n\n      #\n      def run(argv)\n        require 'shomen/rdoc'\n\n        defaults = {}\n        defaults[:format]  = :json\n        defaults[:force]   = false\n\n        options = parse(argv, :format, :force, :visibility, defaults)\n\n        if !options[:force] && !root?\n          $stderr.puts \"Not a project directory. Use --force to override.\"\n          exit -1\n        end\n\n        if argv.empty?\n          if File.exist?('.document')\n            files = File.read('.document').split(\"\\n\")\n            files.reject!{ |f| f.strip == '' }\n          else\n            files = ['lib']\n          end\n        else\n          files = argv\n        end\n\n        tmpdir     = File.join(Dir.tmpdir, 'shomen-rdoc')\n        main       = options[:main] || Dir.glob('{README.*,README}').first\n        visibility = options[:visibility].to_s\n\n        # TODO: Any way to supress the cretion of the time stamp altogether?\n        # Options#update_output_dir for instance?\n\n        # TODO: Using the ::RDoc::Options doesn't seem to work.\n        # It complains about a template being nil in `rdoc/options.rb:760`.\n\n        #rdoc_options = ::RDoc::Options.new\n        #rdoc_options.generator = 'shomen'\n        #rdoc_options.main_page = Dir.glob('README*').first\n        ##rdoc_options.template  = 'shomen'\n        ##rdoc_options.template_dir = File.dirname(__FILE__)\n        #rdoc_options.op_dir    = 'tmp/rdoc'  # '/dev/null'\n        #rdoc_options.files     = files\n\n        rdoc_options  = []\n        rdoc_options += ['-q']\n        #rdoc_options += ['-t', title]\n        rdoc_options += ['-f', 'shomen']\n        rdoc_options += ['-m', main] if main\n        rdoc_options += ['-V', visibility]\n        rdoc_options += ['-o', tmpdir]  # '/dev/null'\n        rdoc_options += files\n\n        rdoc = ::RDoc::RDoc.new\n        rdoc.document(rdoc_options)\n\n        case options[:format]\n        when :yaml\n          $stdout.puts(rdoc.generator.shomen.to_yaml)\n        else\n          $stdout.puts(JSON.generate(rdoc.generator.shomen))\n        end\n      end\n\n      #\n      def option_visibility(parser, options)\n        parser.on('--private', 'include public, protected and private methods') do\n          options[:visibility] = :private\n        end\n        parser.on('--protected', 'include public and protected methods') do\n          options[:visibility] = :protected\n        end\n      end\n\n      #\n      #def option_document(parser, options)\n      #  parser.on('--document FILE') do |file|\n      #    options[:document] = file\n      #  end\n      #end\n\n      #\n      def option_format(parser, options)\n        parser.on('-f', '--format NAME') do |format|\n          options[:format] = format.to_sym\n        end\n      end\n\n      #\n      def option_main(parser, options)\n        parser.on('-m', '--main FILE') do |file|\n          options[:main] = file\n        end\n      end\n\n      # TODO: Add support for additional options supported by rdoc.\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/cli/abstract","tmpdir","json","shomen/rdoc"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/cli/yard.rb":{"!":"script","path":"lib/shomen/cli/yard.rb","name":"yard.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module CLI\n\n    require 'shomen/cli/abstract'\n\n    # YARD command line interface.\n    #\n    # The yard command provides a utility to generate\n    # a Shomen doc file using YARD's .yardoc cache.\n    #\n    class YARDCommand < Abstract\n\n      #\n      def self.run(*argv)\n        new.run(argv)\n      end\n\n      # New Shomen YARD command line interface.\n      def initialize\n      end\n\n      #\n      def run(argv)\n        require 'shomen/yard'\n\n        force = argv.delete('--force')\n\n        if !(force or root?)\n          $stderr.puts \"ERROR: Not a project directory. Use --force to override.\"\n          exit -1\n        end\n\n        format = (\n          if i = argv.index('--format') || argv.index('-f')\n            argv[i+1]\n            argv.delete_at(i)\n            argv.delete_at(i)\n          else\n            'json'\n          end\n        )\n\n        case format\n        when 'json', 'yaml'\n        else\n          $stderr.puts \"ERROR: Format must be 'yaml` or 'json`.\"\n          exit -1\n        end\n\n        argv.unshift('-n')  # do not generate yard documentation\n        argv.unshift('-q')  # supress yard's usual output\n\n        YARD::Registry.clear  # clear the registry in memory to remove any previous runs\n\n        yard = YARD::CLI::Yardoc.new\n        yard.run(*argv)\n\n        files    = yard.options[:files].map(&:filename) + yard.files\n        database = yard.options[:db]\n\n        options = {}\n        options[:format] = format\n        options[:files]  = files\n        options[:db]     = database\n\n        #options = parse(argv, :yaml, :clear, :db, :yardopts, :force, defaults)\n\n        yard = Shomen::YardAdaptor.new(options)\n        yard.generate\n\n        case format\n        when 'yaml'\n          $stdout.puts(yard.table.to_yaml)\n        else\n          $stdout.puts(yard.table.to_json)\n        end\n      end\n\n      #\n      #def option_yaml(parser, options)\n      #  parser.on('-y', '--yaml', 'output YAML instead of JSON') do\n      #    options[:format] = :yaml\n      #  end\n      #end\n\n      #\n      #def option_clear(parser, options)\n      #  parser.on('-c', '--clear') do\n      #    options[:clear] = true\n      #  end\n      #end\n\n      #\n      #def option_db(parser, options)\n      #  parser.on('-b', '--db DIR') do |dir|\n      #    options[:db] = dir\n      #  end\n      #end\n\n      #\n      #def option_yardopts(parser, options)\n      #  parser.on('--yardopts FILE') do |file|\n      #    options[:yardopts] = file\n      #  end\n      #end\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/cli/abstract","shomen/yard"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/core_ext/hash.rb":{"!":"script","path":"lib/shomen/core_ext/hash.rb","name":"hash.rb","mtime":"2011-09-24 13:42:55 -0400","source":"class Hash\n  def to_h; self; end\nend\n","language":"text/ruby","requires":[],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/metadata.rb":{"!":"script","path":"lib/shomen/metadata.rb","name":"metadata.rb","mtime":"2011-09-24 13:42:55 -0400","source":"require 'yaml'\n\nmodule Shomen\n\n  # Encapsulate metadata, which preferably comes from a .ruby file,\n  # but can fallback to a gemspec.\n  #\n  class Metadata\n    include Enumerable\n\n    # Present working directoty.\n    PWD = Dir.pwd\n\n    #\n    def initialize\n      @data = (\n        data = {}\n        if dotruby\n          data.merge!(YAML.load_file(dotruby))\n        elsif gemspec\n          # prefereably use dotruby library to convert,\n          # but wait until it's more mainstream\n          require 'rubygems/specification'\n          spec = ::Gem::Specification.load(gemspec)\n          data['name']        = spec.name,\n          data['title']       = spec.name.capitalize,\n          data['version']     = spec.version.to_s,\n          data['authors']     = [spec.author],\n          data['description'] = spec.description,\n          data['summary']     = spec.summary,\n          data['resources']   = {'homepage' => spec.homepage}\n        else\n          data['name'] = File.basename(Dir.pwd)\n        end\n        data['path'] = '(metadata)'\n        data\n      )\n    end\n\n    #\n    def dotruby\n      file = File.join(PWD, '.ruby')\n      return nil unless File.exist?(file)\n      file\n    end\n\n    #\n    def gemspec\n      file = Dir[File.join(PWD, '{,*}.gemspec')].first\n      return nil unless File.exist?(file)\n      file\n    end\n\n    #\n    def [](name)\n      @data[name]\n    end\n\n    #\n    def size\n      @data.size\n    end\n\n    #\n    def each(&blk)\n      @data.each(&blk)\n    end\n\n    #\n    def to_h\n      @data\n    end\n\n\n  #\n  def generate_metadata(table)\n    begin\n      #require 'pom/project'\n      generate_metadata_from_spec(table)\n    rescue Exception => error\n      puts error\n      begin\n        if spec = Dir['*.gemspec'].first\n          require 'rubygems/specification'\n          generate_metadata_from_gemspec(table)\n        end\n      rescue Exception\n        debug_msg \"Could not find any meatadata.\"\n      end\n    end\n  end\n\n  #\n  SPEC_GLOB = '{.ruby,.rubyspec}'\n\n  #\n  def generate_metadata_from_spec(table)\n    file = Dir[path_base + SPEC_GLOB].first\n    data = YAML.load(File.new(file))\n    table['(metadata)'] = {\n      \"!\"           => \"metadata\",\n      \"name\"        => data['name'],\n      \"version\"     => data['version'],\n      \"title\"       => data['title'],\n      \"summary\"     => data['summary'],\n      \"description\" => data['description'],\n      \"contact\"     => data['contact'],\n      \"resources\"   => data['resources'],\n      \"markup\"      => 'rdoc'\n    }\n  end\n\n  #\n  #def generate_metadata_from_pom(table)\n  #  project = POM::Project.new\n  #  table['(metadata)'] = {\n  #    \"!\"           => \"metadata\",\n  #    \"name\"        => project.name,\n  #    \"version\"     => project.version,\n  #    \"title\"       => project.title,\n  #    \"summary\"     => project.metadata.summary,\n  #    \"description\" => project.metadata.description,\n  #    \"contact\"     => project.metadata.contact,\n  #    \"homepage\"    => project.metadata.resources.home\n  #  }\n  #end\n\n  #\n  GEMSPEC_GLOB = '{.gemspec,*.gemspec}'\n\n  # Metadata follows the .ruby specification.\n  def generate_metadata_from_gemspec(table)\n    file = Dir[path_base + GEMSPEC_GLOB].first\n    spec = RubyGems::Specification.new(file)  #?\n    table['(metadata)'] = {\n      \"!\"           => \"metadata\",\n      \"key\"         => \"(metadata)\",\n      \"name\"        => spec.name,\n      \"title\"       => spec.name.upcase,\n      \"version\"     => spec.version.to_s,\n      \"summary\"     => spec.summary,\n      \"description\" => spec.description,\n      \"contact\"     => spec.email,\n      \"resources\"   => { \"homepage\" => spec.homepage },\n      \"markup\"      => 'rdoc'\n    }\n  end\n\n  #\n  #def metadata\n  #  @metadata ||= get_metadata\n  #end\n\n  # TODO: Need a better way to determine if POM::Metadata exists.\n  #def get_metadata\n  #  data = OpenStruct.new\n  #  begin\n  #    require 'gemdo/metadata'\n  #    pom = GemDo::Metadata.new(path_base)\n  #    raise LoadError unless pom.name\n  #    data.title       = pom.title\n  #    data.version     = pom.version\n  #    data.subtitle    = nil #pom.subtitle\n  #    data.homepage    = pom.homepage\n  #    data.resources   = pom.resources\n  #    data.mailinglist = pom.resources.mailinglist\n  #    data.development = pom.resources.development\n  #    data.forum       = pom.forum\n  #    data.wiki        = pom.wiki\n  #    data.blog        = pom.blog\n  #    data.copyright   = pom.copyright\n  #  rescue LoadError\n  #    if file = Dir[path_base + '*.gemspec'].first\n  #      gem = YAML.load(file)\n  #      data.title       = gem.title\n  #      data.version     = gem.version\n  #      data.subtitle    = nil\n  #      date.homepage    = gem.homepage\n  #      data.mailinglist = gem.email\n  #      data.development = nil\n  #      data.forum       = nil\n  #      data.wiki        = nil\n  #      data.blog        = nil\n  #      data.copyright   = nil\n  #    else\n  #      puts \"No Metadata!\"\n  #      # TODO: we may be able to develop some other hueristics here, but for now, nope.\n  #    end\n  #  end\n  #  return data\n  #end\n\n  end\n\nend\n","language":"text/ruby","requires":["yaml","rubygems/specification","rubygems/specification"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model.rb":{"!":"script","path":"lib/shomen/model.rb","name":"model.rb","mtime":"2011-09-24 13:42:55 -0400","source":"if RUBY_VERSION > '1.9'\n  require_relative 'model/abstract'\n  require_relative 'model/document'\n  require_relative 'model/script'\n  require_relative 'model/module'\n  require_relative 'model/class'\n  require_relative 'model/method'\n  require_relative 'model/attribute'\n#  require_relative 'model/function'\n  require_relative 'model/constant'\nelse\n  require 'shomen/model/abstract'\n  require 'shomen/model/document'\n  require 'shomen/model/script'\n  require 'shomen/model/module'\n  require 'shomen/model/class'\n  require 'shomen/model/method'\n  require 'shomen/model/attribute'\n#  require 'shomen/model/function'\n  require 'shomen/model/constant'\nend\n","language":"text/ruby","requires":["shomen/model/abstract","shomen/model/document","shomen/model/script","shomen/model/module","shomen/model/class","shomen/model/method","shomen/model/attribute","shomen/model/constant"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/abstract.rb":{"!":"script","path":"lib/shomen/model/abstract.rb","name":"abstract.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  require 'shomen/core_ext/hash'\n\n  module Model\n\n    # Baseclass for all model classes.\n    #\n    class AbstractPrime\n      #\n      def self.attr_accessor(name)\n        name = name.to_s\n        define_method(name) do\n          self[name]\n        end\n        define_method(name+'=') do |x|\n          self[name] = x\n        end\n      end\n\n      #\n      def self.type\n        name.split('::').last.downcase\n      end\n\n      #\n      def initialize(settings={})\n        @table = {}\n        settings.each do |k,v|\n          s = \"#{k}=\".gsub('-','_')\n          __send__(s,v)\n        end\n      end\n\n      #\n      def [](k)\n        @table[k.to_s]\n      end\n\n      #\n      def []=(k,v)\n        @table[k.to_s] = v\n      end\n\n      #\n      def to_h\n        t = {}\n        @table.each do |k,v|\n          if v.respond_to?(:to_h)\n            t[k] = v.to_h\n          else\n            t[k] = v\n          end\n        end\n        t\n      end\n\n    end\n\n    #\n    class Abstract < AbstractPrime\n\n      #\n      def initialize(settings={})\n        super(settings)\n        @table['!'] = self.class.type\n      end\n\n      # Full name.\n      attr_accessor :path\n\n      # Hash of label => description.\n      attr_accessor :tags\n\n      #\n      def type\n        self['!']\n      end\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/core_ext/hash"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/attribute.rb":{"!":"script","path":"lib/shomen/model/attribute.rb","name":"attribute.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/method'\n\n    #\n    class Attribute < Method\n      #\n      def self.type; 'attribute'; end\n\n      #\n      def initialize(settings={})\n        super(settings)\n        self['!'] = settings['singleton'] ? 'class-attribute' : 'attribute'\n      end\n\n      # 'R', 'W' or 'RW'\n      attr_accessor :rw\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/method"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/class.rb":{"!":"script","path":"lib/shomen/model/class.rb","name":"class.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n    require 'shomen/model/module'\n\n    #\n    class Class < Module\n\n      #\n      def self.type; 'class'; end\n\n      #\n      attr_accessor :superclass\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/module"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/constant.rb":{"!":"script","path":"lib/shomen/model/constant.rb","name":"constant.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/abstract'\n\n    #\n    class Constant < Abstract\n      #\n      def self.type; 'constant'; end\n\n      # Constant's basename, must start with a capitalized letter.\n      attr_accessor :name\n\n      #\n      attr_accessor :namespace\n\n      #\n      attr_accessor :comment\n\n      # Format of comment (rdoc, markdown or plain).\n      attr_accessor :format\n\n      #\n      attr_accessor :value\n\n      #\n      attr_accessor :files\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/abstract"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/document.rb":{"!":"script","path":"lib/shomen/model/document.rb","name":"document.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/abstract'\n\n    #\n    class Document < Abstract\n      #\n      def self.type\n        'document'\n      end\n\n      #def key=(path)\n      #  path = '/' + path unless path[0,1] == '/'\n      #  super(path)\n      #end\n\n      attr_accessor :name\n\n      #attr_accessor :parent\n\n      attr_accessor :path\n\n      attr_accessor :mtime\n\n      attr_accessor :text\n\n      # Format of comment (rdoc, markdown or plain).\n      attr_accessor :format\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/abstract"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/interface.rb":{"!":"script","path":"lib/shomen/model/interface.rb","name":"interface.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/abstract'\n\n    #\n    class Interface < AbstractPrime\n\n      # TODO: validate that there is an interface image.\n      def initialize(settings={})\n        #@table = {'arguments'=>[], 'parameters'=>[]}\n        super(settings)\n      end\n\n      # The source code \"image\" of the method's inteface.\n      attr_accessor :signature\n\n      # Arguments breakdown.\n      attr_accessor :arguments\n\n      # Parameters breakdown.\n      attr_accessor :parameters\n\n      # Block\n      attr_accessor :block\n\n      # Return value.\n      attr_accessor :returns\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/abstract"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/method.rb":{"!":"script","path":"lib/shomen/model/method.rb","name":"method.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/abstract'\n    require 'shomen/model/interface'\n\n    #\n    class Method < Abstract\n\n      #\n      def initialize(settings={})\n        super(settings)\n        @table['declarations'] ||= []\n      end\n\n      # Method's name.\n      attr_accessor :name\n\n      # Method's namespace.\n      attr_accessor :namespace\n\n      # Comment accompanying method definition.\n      attr_accessor :comment\n\n      # Format of comment (rdoc, markdown or plain).\n      attr_accessor :format\n\n      # Singleton method `true` or `false/nil`.\n      attr_accessor :singleton\n\n      # Delarations is a list of keywords that designates characteristics\n      # about a method. Common characteristics include `reader`, `writer`\n      # or `accessor` if the method is defined via an attr method; `public`\n      # `private` or `protected` given the methods visibility; and `class`\n      # or `instance` given the methods scope. Default designations are\n      # are impled if not specifically stated, such as `public` and `instance`.\n      #\n      # Using a declarations list simplifies the Shomen data format by allowing\n      # declarations to be freely defined, rather than creating a field for each\n      # possible designation possible.\n      attr_accessor :declarations\n\n      # Aliases.\n      attr_accessor :aliases\n\n      # Aliases.\n      attr_accessor :alias_for\n\n      # Breakdown of interfaces signature, arguments, parameters, block argument\n      # an return values.\n      attr_accessor :interfaces\n\n      #\n      def interfaces=(array)\n        self['interfaces'] = (\n          array.map do |settings|\n            case settings\n            when Interface\n              settings\n            else\n              Interface.new(settings)\n            end\n          end\n        )\n      end\n\n      # List of possible returns types.\n      attr_accessor :returns\n\n      # Method generated dynamically?\n      attr_accessor :dynamic\n\n      # Filename.\n      attr_accessor :file\n\n      # Line number.\n      attr_accessor :line\n\n      # Source code.\n      attr_accessor :source\n\n      # Source code language.\n      attr_accessor :language\n\n\n      # Deprecated method.\n      alias :parent :namespace\n\n      #\n      def to_h\n        h = super\n        h['!'] = 'method'\n        h['interfaces'] = (interfaces || []).map{ |s| s.to_h }\n        h\n      end\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/abstract","shomen/model/interface"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/module.rb":{"!":"script","path":"lib/shomen/model/module.rb","name":"module.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/abstract'\n\n    #\n    class Module < Abstract\n\n      #\n      def self.type; 'module'; end\n\n      # Method's name.\n      attr_accessor :name\n\n      # Namespace of module is the path of the class or module\n      # containing this module.\n      attr_accessor :namespace\n\n      # Comment associated with module.\n      attr_accessor :comment\n\n      # Format of comment (rdoc, markdown or plain).\n      attr_accessor :format\n\n      # Mixins.\n      attr_accessor :includes\n\n      # Metaclass mixins.\n      attr_accessor :extensions\n\n      # Constants defined within this module.\n      attr_accessor :constants\n\n      #\n      attr_accessor :modules\n\n      #\n      attr_accessor :classes\n\n      # List of instance methods defined in the module.\n      attr_accessor :methods\n\n      # List of attributes.\n      attr_accessor :accessors\n\n      # The files in which the module is defined.\n      attr_accessor :files\n\n      #\n      alias :fullname :path\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/abstract"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/model/script.rb":{"!":"script","path":"lib/shomen/model/script.rb","name":"script.rb","mtime":"2011-09-24 13:42:55 -0400","source":"module Shomen\n\n  module Model\n\n    require 'shomen/model/document'\n\n    #\n    class Script < Document\n      #\n      def self.type; 'script'; end\n\n      #\n      attr_accessor :source\n\n      # Route textto source.\n      alias :text  :source\n      alias :text= :source=\n\n      #\n      attr_accessor :language\n\n      #\n      attr_accessor :name\n\n      attr_accessor :path\n\n      attr_accessor :mtime\n\n      attr_accessor :header\n\n      attr_accessor :footer\n\n      attr_accessor :requires\n\n      attr_accessor :constants\n\n      attr_accessor :modules\n\n      attr_accessor :classes\n\n      attr_accessor :class_methods\n\n      attr_accessor :methods\n\n    end\n\n  end\n\nend\n","language":"text/ruby","requires":["shomen/model/document"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/rdoc.0.rb":{"!":"script","path":"lib/shomen/rdoc.0.rb","name":"rdoc.0.rb","mtime":"2011-09-24 13:42:55 -0400","source":"#begin\n#  # requiroing rubygems is needed here b/c ruby comes with\n#  # rdoc but it's not the latest version.\n#  require 'rubygems'\n#  #gem 'rdoc', '>= 2.4' unless ENV['RDOC_TEST'] or defined?($rdoc_rakefile)\n#  gem \"rdoc\", \">= 2.4.2\"\n#rescue\n#end\n\n#if Gem.available? \"json\"\n#  gem \"json\", \">= 1.1.3\"\n#else\n#  gem \"json_pure\", \">= 1.1.3\"\n#end\n#require 'json'\n\nrequire 'fileutils'\nrequire 'pp'\nrequire 'pathname'\nrequire 'yaml'\nrequire 'json'\n\nrequire 'rdoc/rdoc'\nrequire 'rdoc/generator'\nrequire 'rdoc/generator/markup'\n\nrequire 'shomen/model'\n\nrequire 'shomen/rdoc/extensions'\nrequire 'shomen/rdoc/module'\n\n#require 'shomen/metadata'\n\n## TODO: Is this needed?\n## TODO: options = { :verbose => $DEBUG_RDOC, :noop => $dryrun }\n#def fileutils\n#  $dryrun ? FileUtils::DryRun : FileUtils\n#end\n\n# Shomen Adaptor for RDoc\n#\n# Of course RDoc is almost entirely a free-form documentation system,\n# so it is not possible for Shomen to fully harness all the details it\n# can support from the RDoc documentation.\n#\n# NOTE: This is probably slightly out of date with the current spec.\n\nclass RDoc::Generator::Shomen\n\n  # Register shomen generator with RDoc.\n  RDoc::RDoc.add_generator(self)\n\n  # Base of file name used to save output.\n  #FILENAME = \"shomen\"\n\n  #include RDocShomen::Metadata\n\n  #PATH = Pathname.new(File.dirname(__FILE__))\n\n  # Standard generator factory method.\n  def self.for(options)\n    new(options)\n  end\n\n  # User options from the command line.\n  attr :options\n\n  # List of all classes and modules.\n  #def all_classes_and_modules\n  #  @all_classes_and_modules ||= RDoc::TopLevel.all_classes_and_modules\n  #end\n\n  # In the world of the RDoc Generators #classes is the same\n  # as #all_classes_and_modules. Well, except that its sorted \n  # too. For classes sans modules, see #types.\n\n  def classes\n    @classes ||= RDoc::TopLevel.all_classes_and_modules.sort\n  end\n\n  # Only toplevel classes and modules.\n  def classes_toplevel\n    @classes_toplevel ||= classes.select {|klass| !(RDoc::ClassModule === klass.parent) }\n  end\n\n  ## Documented classes and modules sorted by salience first, then by name.\n  #def classes_salient\n  #  @classes_salient ||= sort_salient(classes)\n  #end\n\n  #\n  #def classes_hash\n  #  @classes_hash ||= RDoc::TopLevel.modules_hash.merge(RDoc::TopLevel.classes_hash)\n  #end\n\n  #\n  #def modules\n  #  @modules ||= RDoc::TopLevel.modules.sort\n  #end\n\n  #\n  #def modules_toplevel\n  #  @modules_toplevel ||= modules.select {|klass| !(RDoc::ClassModule === klass.parent) }\n  #end\n\n  #\n  #def modules_salient\n  #  @modules_salient ||= sort_salient(modules)\n  #end\n\n  #\n  #def modules_hash\n  #  @modules_hash ||= RDoc::TopLevel.modules_hash\n  #end\n\n  #\n  #def types\n  #  @types ||= RDoc::TopLevel.classes.sort\n  #end\n\n  #\n  #def types_toplevel\n  #  @types_toplevel ||= types.select {|klass| !(RDoc::ClassModule === klass.parent) }\n  #end\n\n  #\n  #def types_salient\n  #  @types_salient ||= sort_salient(types)\n  #end\n\n  #\n  #def types_hash\n  #  @types_hash ||= RDoc::TopLevel.classes_hash\n  #end\n\n  #\n  def files\n    @files ||= RDoc::TopLevel.files\n  end\n\n  # List of toplevel files. RDoc supplies this via the #generate method.\n  def files_toplevel\n    @files_toplevel ||= (\n      @files_rdoc.select{ |f| f.parser == RDoc::Parser::Simple }\n    )\n  end\n\n  #\n\n  def files_hash\n    @files ||= RDoc::TopLevel.files_hash\n  end\n\n  # List of all methods in all classes and modules.\n  def methods_all\n    @methods_all ||= classes.map{ |m| m.method_list }.flatten.sort\n  end\n\n  # List of all attributes in all classes and modules.\n  def attributes_all\n    @attributes_all ||= classes.map{ |m| m.attributes }.flatten.sort\n  end\n\n  ## TODO: What's this then?\n  ##def json_creatable?\n  ##  RDoc::TopLevel.json_creatable?\n  ##end\n\n  # RDoc needs this to function.\n  def class_dir ; nil ; end\n\n  # RDoc needs this to function.\n  def file_dir  ; nil ; end\n\n  #\n  def shomen\n    @table || {}\n  end\n\n  # Build the initial indices and output objects\n  # based on an array of top level objects containing\n  # the extracted information.\n  def generate(files)\n    @files_rdoc = files.sort\n\n    @table = {}\n\n    generate_metadata\n    generate_constants\n    generate_classes\n    generate_attributes\n    generate_methods\n    generate_files\n    generate_scripts   # must be last b/c it depends on the others\n\n    #pp table if $DEBUG\n\n    #file = File.join(path_output, FILENAME)\n\n    #yaml = @table.to_yaml\n    #File.open(file + '.yaml', 'w'){ |f| f << yaml }\n\n    #json = JSON.generate(@table)\n    #File.open(file + '.json', 'w'){ |f| f << json }\n\n    # TODO: Internal referencing model, YAML and JSYNC ?\n\n    #ref_table = reference_table(@table)\n    #yaml = ref_table.to_yaml\n    #File.open(FILENAME + '-ref.yaml', 'w'){ |f| f << yaml }\n\n  #rescue StandardError => err\n  #  debug_msg \"%s: %s\\n  %s\" % [ err.class.name, err.message, err.backtrace.join(\"\\n  \") ]\n  #  raise err\n  end\n\n=begin\n  # Loop through table and convert all named references into bonofied object\n  # references.\n  def reference_table(table)\n    debug_msg \"== Generating Reference Table\"\n    new_table = {}\n    table.each do |key, entry|\n      debug_msg \"%s\" % [key]\n      data = entry.dup\n      new_table[key] = data\n      case data['!']\n      when 'script'\n        data[\"constants\"]  = ref_list(data[\"constants\"])\n        data[\"modules\"]    = ref_list(data[\"modules\"])\n        data[\"classes\"]    = ref_list(data[\"classes\"])\n        data[\"functions\"]  = ref_list(data[\"functions\"])\n        data[\"methods\"]    = ref_list(data[\"methods\"])\n      when 'file'\n      when 'constant'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n      when 'module', 'class'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n        data[\"includes\"]   = ref_list(data[\"includes\"])\n        #data[\"extended\"]  = ref_list(data[\"extended\"])\n        data[\"constants\"]  = ref_list(data[\"constants\"])\n        data[\"modules\"]    = ref_list(data[\"modules\"])\n        data[\"classes\"]    = ref_list(data[\"classes\"])\n        data[\"functions\"]  = ref_list(data[\"functions\"])\n        data[\"methods\"]    = ref_list(data[\"methods\"])\n        data[\"files\"]      = ref_list(data[\"files\"])\n        data[\"superclass\"] = ref_item(data[\"superclass\"]) if data.key?(\"superclass\")\n      when 'method', 'function'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n        data[\"file\"]       = ref_item(data[\"file\"])\n      end\n    end\n    new_table\n  end\n=end\n\n  # Given a key, return the matching table item. If not found return the key.\n  def ref_item(key)\n    @table[key] || key\n  end\n\n  # Given a list of keys, return the matching table items.\n  def ref_list(keys)\n    #keys.map{ |k| @table[k] || k }\n    keys.map{ |k| @table[k] || nil }.compact\n  end\n\n  #\n  #def metadata\n  #  @metadata ||= get_metadata\n  #end\n\n  # TODO: Need a better way to determine if POM::Metadata exists.\n  #def get_metadata\n  #  data = OpenStruct.new\n  #  begin\n  #    require 'gemdo/metadata'\n  #    pom = GemDo::Metadata.new(path_base)\n  #    raise LoadError unless pom.name\n  #    data.title       = pom.title\n  #    data.version     = pom.version\n  #    data.subtitle    = nil #pom.subtitle\n  #    data.homepage    = pom.homepage\n  #    data.resources   = pom.resources\n  #    data.mailinglist = pom.resources.mailinglist\n  #    data.development = pom.resources.development\n  #    data.forum       = pom.forum\n  #    data.wiki        = pom.wiki\n  #    data.blog        = pom.blog\n  #    data.copyright   = pom.copyright\n  #  rescue LoadError\n  #    if file = Dir[path_base + '*.gemspec'].first\n  #      gem = YAML.load(file)\n  #      data.title       = gem.title\n  #      data.version     = gem.version\n  #      data.subtitle    = nil\n  #      date.homepage    = gem.homepage\n  #      data.mailinglist = gem.email\n  #      data.development = nil\n  #      data.forum       = nil\n  #      data.wiki        = nil\n  #      data.blog        = nil\n  #      data.copyright   = nil\n  #    else\n  #      puts \"No Metadata!\"\n  #      # TODO: we may be able to develop some other hueristics here, but for now, nope.\n  #    end\n  #  end\n  #  return data\n  #end\n\nprotected\n\n  #\n  def initialize(options)\n    @options = options\n    #@options.diagram = false  # why?\n\n    @path_base   = Pathname.pwd.expand_path\n    @path_output = Pathname.new(@options.op_dir).expand_path(@path_base)\n  end\n\n  # Current pathname.\n  attr :path_base\n\n  # The output path.\n  attr :path_output\n\n  #\n  def path_output_relative(path=nil)\n    if path\n      path.to_s.sub(path_base.to_s+'/', '')\n    else\n      @path_output_relative ||= path_output.to_s.sub(path_base.to_s+'/', '')\n    end\n  end\n\n  #\n  def generate_metadata\n    metadata = Shomen::Metadata.new\n    @table['(metadata)'] = metadata.to_h\n  end\n\n  # Add constants to table.\n  def generate_constants\n    debug_msg \"Generating constant documentation:\"\n    classes.each do |base|\n      base.constants.each do |rdoc_constant|\n        adapter = Shomen::RDoc::ConstantAdapter.new(rdoc_constant)\n        data    = Shomen::Model::Constant.new(adapter).to_h\n\n        #full_name = \"#{base.full_name}::#{c.name}\"\n        #debug_msg \"%s\" % [full_name]\n        #@table[full_name] = Shomen::Model::Constant.new(\n        #  \"key\"       => full_name,\n        #  \"name\"      => c.name,\n        #  \"namespace\" => \"#{base.full_name}\",\n        #  \"comment\"   => c.comment, # description\n        #  \"value\"     => c.value\n        #).to_h\n\n        @table[data['path']] = data\n      end\n    end\n    return table     \n  end\n\n  # Add classes (and modules) to table.\n  def generate_classes(table)\n    debug_msg \"Generating class/module documentation:\"\n    classes.each do |rdoc_class|\n      debug_msg \"%s (%s)\" % [ rdoc_class.full_name, rdoc_class.path ]\n\n      #outfile    = self.path_output + klass.path\n      #rel_prefix = self.path_output.relative_path_from(outfile.dirname)\n      #debug_msg \"rendering #{path_output_relative(outfile)}\"\n      #self.render_template(templatefile, outfile, :klass=>klass, :rel_prefix=>rel_prefix)\n\n      if c.type=='class'\n        adapter = Shomen::RDoc::ClassAdapter.new(rdoc_class)\n        data    = Shomen::Model::Class.new(adapter).to_h\n      else\n        adapter = Shomen::RDoc::ModuleAdapter.new(rdoc_class)\n        data    = Shomen::Model::Module.new(adapter).to_h\n      end\n\n=begin\n      # HACK: No idea why RDoc is returning some weird superclass:\n      #   <RDoc::NormalClass:0xd924d4 class Object < BasicObject includes: []\n      #     attributes: [] methods: [#<RDoc::AnyMethod:0xd92b8c Object#fileutils\n      #     (public)>] aliases: []>\n      # Maybe it has something to do with #fileutils?\n      if c.type == 'class'\n        superclass = (String === c.superclass ? c.superclass.to_s : c.superclass.name)\n      else\n        superclass = nil\n      end\n\n      model = model_class.new(\n        \"key\"              => c.full_name,\n        \"name\"             => c.name,\n        \"namespace\"        => c.full_name.split('::')[0...-1].join('::'),\n        \"includes\"         => c.includes.map{ |x| x.name },  # FIXME: How to \"lookup\" full name?\n        #\"extensions\"       => []  # TODO: how?\n        \"comment\"          => c.comment,\n        \"constants\"        => c.constants.map{ |x| complete_name(x.name, c.full_name) },\n        \"modules\"          => c.modules.map{ |x| complete_name(x.name, c.full_name) },\n        \"classes\"          => c.classes.map{ |x| complete_name(x.name, c.full_name) },\n        \"methods\"          => collect_methods(c, false),\n        \"class_methods\"    => collect_methods(c, true),\n        \"attributes\"       => collect_attributes(c, false),\n        \"class_attributes\" => collect_attributes(c, true),\n        \"files\"            => c.in_files.map{ |x| x.full_name }\n      )\n      if c.type == 'class'\n        model[\"superclass\"] = superclass || 'Object'\n      end\n=end\n\n      @table[data['path']] = data\n    end\n    return table\n  end\n\n  # Returns String of fully qualified name.\n  def complete_name(name, namespace)\n    if name !~ /^#{namespace}/\n      \"#{namespace}::#{name}\"\n    else\n      name\n    end\n  end\n\n  #\n  def generate_attributes(table)\n    debug_msg \"Generating attributes documentation:\"\n    attributes_all.each do |m|\n      debug_msg \"%s\" % [m.full_name]\n\n      code       = m.source_code_raw\n      file, line = m.source_code_locationModel::Method\n\n      full_name = method_name(m)\n\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      #model_class = m.singleton ? Shomen::Model::Function : Shomen::Model::Method\n      model_class = Shomen::Model::Attribute\n\n      table[full_name] = model_class.new(\n        'key'          => full_name,\n        'name'         => m.name,\n        'namespace'    => m.parent_name,\n        'comment'      => m.comment,\n        'access'       => m.visibility.to_s,\n        'rw'           => m.rw,  # TODO: better name ?\n        'singleton'    => m.singleton,\n        'aliases'      => m.aliases.map{ |a| method_name(a) },\n        'alias_for'    => method_name(m.is_alias_for),\n        'image'        => m.params,\n        'arguments'    => [],\n        'parameters'   => [],\n        'block'        => m.block_params, # TODO: what is block?\n        'interface'    => m.arglists,\n        'returns'      => [],\n        'file'         => file,\n        'line'         => line,\n        'source'       => code\n      ).to_h\n    end\n    return table\n  end\n\n  # Transform RDoc methods to Shomen model and add to table.\n  def generate_methods(table)\n    debug_msg \"Generating method documentation:\"\n\n    methods_all.each do |rdoc_method|\n      debug_msg \"%s\" % [rdoc_method.full_name]\n\n      #code       = m.source_code_raw\n      #file, line = m.source_code_location\n\n      #full_name  = method_name(m)\n\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      #model_class = m.singleton ? Shomen::Model::Function : Shomen::Model::Method\n      #model_class = Shomen::Model::Method\n\n      adapter = Shomen::RDoc::MethodAdapter.new(rdoc_method)\n      data    = Shomen::Model::Method.new().to_h\n\n      @table[data['path']] = data\n\n      #table[full_name] = model_class.new(\n      #  'key'          => full_name,\n      #  'name'         => m.name,\n      #  'namespace'    => m.parent_name,\n      #  'comment'      => m.comment,\n      #  'access'       => m.visibility.to_s,\n      #  'singleton'    => m.singleton,\n      #  'aliases'      => m.aliases.map{ |a| method_name(a) },\n      #  'alias_for'    => method_name(m.is_alias_for),\n      #  'image'        => m.params,\n      #  'arguments'    => [],\n      #  'parameters'   => [],\n      #  'block'        => m.block_params, # TODO: what is block?\n      #  'interface'    => m.arglists,\n      #  'returns'      => [],\n      #  'file'         => file,\n      #  'line'         => line,\n      #  'source'       => code\n      #).to_h\n    end\n  end\n\n  # Generate a documentation file for each file.\n  #--\n  # TODO: Add loadpath and make file path relative to it?\n  #++\n  def generate_scripts(table)\n    debug_msg \"Generating file documentation in #{path_output_relative}:\"\n    #templatefile = self.path_template + 'file.rhtml'\n\n    files.each do |file|\n      debug_msg \"%s\" % [file.full_name]\n\n      abspath = File.join(path_base, file.full_name)\n\n      #rel_prefix  = self.path_output.relative_path_from(outfile.dirname)\n      #context     = binding()\n      #debug_msg \"rendering #{path_output_relative(outfile)}\"\n\n      modules = table.select { |k, h|\n        h['!'] == 'module' && h['files'].include?(file.full_name)\n      }.map{ |k, h| k }\n\n      classes = table.select { |k, h|\n        h['!'] == 'class' && h['files'].include?(file.full_name)\n      }.map{ |k, h| k }\n\n      methods = table.select { |k, h|\n        h['!'] == 'method' && h['file'] == file.full_name\n      }.map{ |k, h| k }\n\n      class_methods = table.select { |k, h|\n        h['!'] == 'class-method' && h['file'] == file.full_name\n      }.map{ |k, h| k }\n\n      adapter = Shomen::RDoc::ScriptAdapter.new(adapter)\n      data    = Shomen::Model::Script.new(adapter).to_h\n\n      data['methods']       = methods\n      data['class-methods'] = class_methods\n      data['classes']       = classes\n      data['modules']       = modules\n\n      @table['/'+data['path']] = data\n\n      #Shomen::Model::Script.new(\n      #  \"key\"            => file.full_name,\n      #  \"name\"           => File.basename(file.full_name),\n      #  \"parent\"         => File.dirname(file.full_name),\n      #  \"path\"           => file.full_name,\n      #  \"mtime\"          => File.mtime(abspath),\n      #  \"header\"         => \"\", # TODO\n      #  \"footer\"         => \"\", # TODO\n      #  \"requires\"       => file.requires.map{ |r| r.name },\n      #  \"constants\"      => file.constants.map{ |c| c.full_name },\n      #  \"modules\"        => modules,   #file.modules.map{ |x| x.name },\n      #  \"classes\"        => classes,   #file.classes.map{ |x| x.name },\n      #  \"class-methods\"  => functions, #collect_methods(file, true),\n      #  \"methods\"        => methods,    #collect_methods(file, false)\n      #  \"source\"         => File.read(abspath)\n      #).to_h\n\n      #self.render_template(templatefile, outfile, :file=>file, :rel_prefix=>rel_prefix)\n    end\n  end\n\n  # Generate entries for whole information files, e.g. README files.\n  def generate_files(table)\n    files_toplevel.each do |rdoc_file|\n      adapter = Shomen::RDoc::DocumentAdapter.new(rdoc_file)\n      data    = Shomen::Model::Document.new(adapter).to_h\n\n      @table['/'+data['path']] = data\n\n      #abspath = File.join(path_base, file.full_name)\n      #table[file.full_name] = Shomen::Model::Document.new(\n      #  \"key\"    => file.full_name,\n      #  \"name\"   => File.basename(file.full_name),\n      #  \"parent\" => File.dirname(file.full_name),\n      #  \"path\"   => file.full_name,\n      #  \"mtime\"  => File.mtime(abspath),\n      #  \"text\"   => File.read(abspath) #file.comment\n      #).to_h\n      #table['/'+file.full_name] = data\n    end\n  end\n\n  #\n  def collect_methods(class_module, singleton=false)\n    list = []\n    class_module.method_list.each do |m|\n      next if singleton ^ m.singleton\n      list << method_name(m)\n    end\n    list.uniq\n  end\n\n  def collect_attributes(class_module, singleton=false)\n    list = []\n    class_module.attributes.each do |a|\n      next if singleton ^ a.singleton\n      #p a.rw\n      #case a.rw\n      #when :write, 'W'\n      #  list << \"#{method_name(a)}=\"\n      #else\n        list << method_name(a)\n      #end\n    end\n    list.uniq\n  end\n\n  #\n  def method_name(method)\n    return nil if method.nil?\n    if method.singleton\n      i = method.full_name.rindex('::')     \n      method.full_name[0...i] + '.' + method.full_name[i+2..-1]\n    else\n      method.full_name\n    end\n  end\n\n  # Output progress information if rdoc debugging is enabled\n\n  def debug_msg(msg)\n    return unless $DEBUG_RDOC\n    case msg[-1,1]\n      when '.' then tab = \"= \"\n      when ':' then tab = \"== \"\n      else          tab = \"* \"\n    end\n    $stderr.puts(tab + msg)\n  end\n\nend\n\n\n\n\n=begin\n  #\n  # N O T  U S E D\n  #\n\n  # Sort based on how often the top level namespace occurs, and then on the\n  # name of the module -- this works for projects that put their stuff into\n  # a namespace, of course, but doesn't hurt if they don't.\n  def sort_salient(classes)\n    nscounts = classes.inject({}) do |counthash, klass|\n      top_level = klass.full_name.gsub( /::.*/, '' )\n      counthash[top_level] ||= 0\n      counthash[top_level] += 1\n      counthash\n    endfiles_toplevel\n    classes.sort_by{ |klass|\n      top_level = klass.full_name.gsub( /::.*/, '' )\n      [nscounts[top_level] * -1, klass.full_name]\n    }.select{ |klass|\n      klass.document_self\n    }\n  end\n=end\n\n","language":"text/ruby","requires":["fileutils","pp","pathname","yaml","json","rdoc/rdoc","rdoc/generator","rdoc/generator/markup","shomen/model","shomen/rdoc/extensions","shomen/rdoc/module"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/rdoc.rb":{"!":"script","path":"lib/shomen/rdoc.rb","name":"rdoc.rb","mtime":"2011-09-24 13:42:55 -0400","source":"#begin\n#  # requiroing rubygems is needed here b/c ruby comes with\n#  # rdoc but it's not the latest version.\n#  require 'rubygems'\n#  #gem 'rdoc', '>= 2.4' unless ENV['RDOC_TEST'] or defined?($rdoc_rakefile)\n#  gem \"rdoc\", \">= 2.4.2\"\n#rescue\n#end\n\nrequire 'fileutils'\nrequire 'pathname'\nrequire 'yaml'\nrequire 'json'\n\nrequire 'rdoc/rdoc'\nrequire 'rdoc/generator'\nrequire 'rdoc/generator/markup'\n\nrequire 'shomen/metadata'\nrequire 'shomen/model'  # TODO: have metadata in model\nrequire 'shomen/rdoc/extensions'\n\n# Shomen Adaptor for RDoc utilizes the rdoc tool to parse ruby source code\n# to build a Shomen documenation file.\n#\n# RDoc is almost entirely a free-form documentation system, so it is not\n# possible for Shomen to fully harness all the details it can support from\n# the RDoc documentation, such as method argument descriptions.\n\nclass RDoc::Generator::Shomen\n\n  # Register shomen generator with RDoc.\n  RDoc::RDoc.add_generator(self)\n\n  #include RDocShomen::Metadata\n\n  # Standard generator factory method.\n  def self.for(options)\n    new(options)\n  end\n\n  # User options from the command line.\n  attr :options\n\n  # List of all classes and modules.\n  #def all_classes_and_modules\n  #  @all_classes_and_modules ||= RDoc::TopLevel.all_classes_and_modules\n  #end\n\n  # In the world of the RDoc Generators #classes is the same\n  # as #all_classes_and_modules. Well, except that its sorted \n  # too. For classes sans modules, see #types.\n\n  def classes\n    @classes ||= RDoc::TopLevel.all_classes_and_modules.sort\n  end\n\n  # Only toplevel classes and modules.\n  def classes_toplevel\n    @classes_toplevel ||= classes.select {|klass| !(RDoc::ClassModule === klass.parent) }\n  end\n\n  #\n  def files\n    @files ||= (\n      @files_rdoc.select{ |f| f.parser != RDoc::Parser::Simple }\n    )\n  end\n\n  # List of toplevel files. RDoc supplies this via the #generate method.\n  def files_toplevel\n    @files_toplevel ||= (\n      @files_rdoc.select{ |f| f.parser == RDoc::Parser::Simple }\n    )\n  end\n\n  #\n\n  def files_hash\n    @files ||= RDoc::TopLevel.files_hash\n  end\n\n  # List of all methods in all classes and modules.\n  def methods_all\n    @methods_all ||= classes.map{ |m| m.method_list }.flatten.sort\n  end\n\n  # List of all attributes in all classes and modules.\n  def attributes_all\n    @attributes_all ||= classes.map{ |m| m.attributes }.flatten.sort\n  end\n\n  #\n  def constants_all\n    @constants_all ||= classes.map{ |c| c.constants }.flatten\n  end\n\n  ## TODO: What's this then?\n  ##def json_creatable?\n  ##  RDoc::TopLevel.json_creatable?\n  ##end\n\n  # RDoc needs this to function.\n  def class_dir ; nil ; end\n\n  # RDoc needs this to function.\n  def file_dir  ; nil ; end\n\n  # TODO: Rename ?\n  def shomen\n    @table || {}\n  end\n\n  # Build the initial indices and output objects\n  # based on an array of top level objects containing\n  # the extracted information.\n  def generate(files)\n    @files_rdoc = files.sort\n\n    @table = {}\n\n    generate_metadata\n    generate_constants\n    generate_classes\n    #generate_attributes\n    generate_methods\n    generate_documents\n    generate_scripts   # must be last b/c it depends on the others\n\n    # TODO: method accessor fields need to be handled\n\n    # THINK: Internal referencing model, YAML and JSYNC ?\n    #ref_table = reference_table(@table)\n\n  #rescue StandardError => err\n  #  debug_msg \"%s: %s\\n  %s\" % [ err.class.name, err.message, err.backtrace.join(\"\\n  \") ]\n  #  raise err\n  end\n\n\nprotected\n\n  #\n  def initialize(options)\n    @options = options\n    #@options.diagram = false  # why?\n\n    @path_base   = Pathname.pwd.expand_path\n\n    # TODO: This is probably not needed any more.\n    @path_output = Pathname.new(@options.op_dir).expand_path(@path_base)\n  end\n\n  # Current pathname.\n  attr :path_base\n\n  # The output path.\n  attr :path_output\n\n  #\n  def path_output_relative(path=nil)\n    if path\n      path.to_s.sub(path_base.to_s+'/', '')\n    else\n      @path_output_relative ||= path_output.to_s.sub(path_base.to_s+'/', '')\n    end\n  end\n\n  #\n  def generate_metadata\n    metadata = Shomen::Metadata.new\n    @table['(metadata)'] = metadata.to_h\n  end\n\n  # Add constants to table.\n  def generate_constants\n    debug_msg \"Generating constant documentation:\"\n    constants_all.each do |rdoc|\n      model = Shomen::Model::Constant.new\n\n      model.path      = rdoc.parent.full_name + '::' + rdoc.name\n      model.name      = rdoc.name\n      model.namespace = rdoc.parent.full_name\n      model.comment   = rdoc.comment\n      model.format    = 'rdoc'\n      model.value     = rdoc.value\n      model.files     = [\"/#{rdoc.file.full_name}\"]\n\n      @table[model.path] = model.to_h\n    end\n  end\n\n  # Add classes (and modules) to table.\n  def generate_classes\n    debug_msg \"Generating class/module documentation:\"\n\n    classes.each do |rdoc_class|\n      debug_msg \"%s (%s)\" % [ rdoc_class.full_name, rdoc_class.path ]\n\n      if rdoc_class.type=='class'\n        model = Shomen::Model::Class.new\n      else\n        model = Shomen::Model::Module.new\n      end\n\n      model.path             = rdoc_class.full_name\n      model.name             = rdoc_class.name\n      model.namespace        = rdoc_class.full_name.split('::')[0...-1].join('::')\n      model.includes         = rdoc_class.includes.map{ |x| x.name }  # FIXME: How to \"lookup\" full name?\n      model.extensions       = []                                     # TODO:  How to get extensions?\n      model.comment          = rdoc_class.comment\n      model.format           = 'rdoc'\n      model.constants        = rdoc_class.constants.map{ |x| complete_name(x.name, rdoc_class.full_name) }\n      model.modules          = rdoc_class.modules.map{ |x| complete_name(x.name, rdoc_class.full_name) }\n      model.classes          = rdoc_class.classes.map{ |x| complete_name(x.name, rdoc_class.full_name) }\n      model.methods          = rdoc_class.method_list.map{ |m| method_name(m) }.uniq\n      model.accessors        = rdoc_class.attributes.map{ |a| method_name(a) }.uniq  #+ \":#{a.rw}\" }.uniq\n      model.files            = rdoc_class.in_files.map{ |x| \"/#{x.full_name}\" }\n\n      if rdoc_class.type == 'class'\n        # HACK: No idea why RDoc is returning some weird superclass:\n        #   <RDoc::NormalClass:0xd924d4 class Object < BasicObject includes: []\n        #     attributes: [] methods: [#<RDoc::AnyMethod:0xd92b8c Object#fileutils\n        #     (public)>] aliases: []>\n        # Maybe it has something to do with #fileutils?\n        model.superclass = (\n          if String === rdoc_class.superclass\n            rdoc_class.superclass.to_s \n          else\n            rdoc_class.superclass.name\n          end\n        )\n      end\n\n      @table[model.path] = model.to_h\n    end\n  end\n\n  # Transform RDoc methods to Shomen model and add to table.\n  #\n  # TODO: How to get literal interface separate from call-sequnces?\n  def generate_methods\n    debug_msg \"Generating method documentation:\"\n\n    list = methods_all + attributes_all\n\n    list.each do |rdoc_method|\n      #debug_msg \"%s\" % [rdoc_method.full_name]\n\n      #full_name  = method_name(m)\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      model = Shomen::Model::Method.new\n\n      model.path        = method_name(rdoc_method)\n      model.name        = rdoc_method.name\n      model.namespace   = rdoc_method.parent_name\n      model.comment     = rdoc_method.comment\n      model.format      = 'rdoc'\n      model.aliases     = rdoc_method.aliases.map{ |a| method_name(a) }\n      model.alias_for   = method_name(rdoc_method.is_alias_for)\n      model.singleton   = rdoc_method.singleton\n\n      model.declarations << rdoc_method.type.to_s #singleton ? 'class' : 'instance'\n      model.declarations << rdoc_method.visibility.to_s\n\n      model.interfaces = []\n      if rdoc_method.call_seq\n        rdoc_method.call_seq.split(\"\\n\").each do |cs|\n          model.interfaces << parse_interface(cs)\n        end\n      end\n      model.interfaces << parse_interface(\"#{rdoc_method.name}#{rdoc_method.params}\")\n\n      model.returns    = []  # RDoc doesn't support specifying return values\n      model.file       = '/'+rdoc_method.source_code_location.first\n      model.line       = rdoc_method.source_code_location.last.to_i\n      model.source     = rdoc_method.source_code_raw\n\n      if rdoc_method.respond_to?(:c_function)\n        model.language = rdoc_method.c_function ? 'c' : 'ruby'\n      else\n        model.language = 'ruby'\n      end\n\n      @table[model.path] = model.to_h\n    end\n  end\n\n=begin\n  #\n  def parse_arguments(rdoc_method)\n    args, block  = [], nil\n\n    rdoc_method.param_list.each do |a|\n      if a.start_with?('&')\n        block = {'name'=>a}\n      else\n        n,v = a.split('=')\n        args << (v ? {'name'=>n,'default'=>v} : {'name'=>n})\n      end\n    end\n\n    return args, block\n  end\n=end\n\n  #\n  # TODO: remove any trailing comment too\n  def parse_interface(interface)\n    args, block = [], {}\n\n    interface, returns = interface.split(/[=-]>/)\n    interface = interface.strip\n    if i = interface.index(/\\)\\s*\\{/)\n      block['image'] = interface[i+1..-1].strip\n      interface      = interface[0..i].strip\n    end\n\n    arguments = interface.strip.sub(/^.*?\\(/,'').chomp(')')\n    arguments = arguments.split(/\\s*\\,\\s*/)\n    arguments.each do |a|\n      if a.start_with?('&')\n        block['name'] = a\n      else\n        n,v = a.split('=')\n        args << (v ? {'name'=>n,'default'=>v} : {'name'=>n})\n      end\n    end\n\n    result = {}\n    result['signature'] = interface\n    result['arguments'] = args\n    result['block']     = block unless block.empty?\n    result['returns']   = returns.strip if returns\n    return result\n  end\n  private :parse_interface\n\n=begin\n  #\n  def generate_attributes\n#$stderr.puts \"HERE!\"\n#$stderr.puts attributes_all.inspect\n#exit\n    debug_msg \"Generating attributes documentation:\"\n    attributes_all.each do |rdoc_attribute|\n      debug_msg \"%s\" % [rdoc_attribute.full_name]\n\n      adapter = Shomen::RDoc::MethodAdapter.new(rdoc_attribute)\n      data    = Shomen::Model::Method.new(adapter).to_h\n\n      @table[data['path']] = data\n\n      #code       = m.source_code_raw\n      #file, line = m.source_code_location\n\n      #full_name = method_name(m)\n\n      #'prettyname'   => m.pretty_name,\n      #'type'         => m.type, # class or instance\n\n      #model_class = m.singleton ? Shomen::Model::Function : Shomen::Model::Method\n      #model_class = Shomen::Model::Attribute\n\n      #@table[full_name] = model_class.new(\n      #  'path'         => full_name,\n      #  'name'         => m.name,\n      #  'namespace'    => m.parent_name,\n      #  'comment'      => m.comment,\n      #  'access'       => m.visibility.to_s,\n      #  'rw'           => m.rw,  # TODO: better name ?\n      #  'singleton'    => m.singleton,\n      #  'aliases'      => m.aliases.map{ |a| method_name(a) },\n      #  'alias_for'    => method_name(m.is_alias_for),\n      #  'image'        => m.params,\n      #  'arguments'    => [],\n      #  'parameters'   => [],\n      #  'block'        => m.block_params, # TODO: what is block?\n      #  'interface'    => m.arglists,\n      #  'returns'      => [],\n      #  'file'         => file,\n      #  'line'         => line,\n      #  'source'       => code\n      #).to_h\n    end\n  end\n=end\n\n  # Generate entries for information files, e.g. `README.rdoc`.\n  def generate_documents\n    files_toplevel.each do |rdoc_document|\n      absolute_path = File.join(path_base, rdoc_document.full_name)\n\n      model = Shomen::Model::Document.new\n\n      model.path   = rdoc_document.full_name\n      model.name   = File.basename(absolute_path)\n      model.mtime  = File.mtime(absolute_path)\n      model.text   = File.read(absolute_path) #file.comment\n      model.format = mime_type(absolute_path)\n\n      @table['/'+model.path] = model.to_h\n    end\n  end\n\n  # TODO: Add loadpath and make file path relative to it?\n\n  # Generate script entries.\n  def generate_scripts\n    #debug_msg \"Generating file documentation in #{path_output_relative}:\"\n    #templatefile = self.path_template + 'file.rhtml'\n\n    files.each do |rdoc_file|\n      debug_msg \"%s\" % [rdoc_file.full_name]\n\n      absolute_path = File.join(path_base, rdoc_file.full_name)\n      #rel_prefix  = self.path_output.relative_path_from(outfile.dirname)\n\n      model = Shomen::Model::Script.new\n\n      model.path      = rdoc_file.full_name\n      model.name      = File.basename(rdoc_file.full_name)\n      model.mtime     = File.mtime(absolute_path)\n      model.source    = File.read(absolute_path) #file.comment\n      model.language  = mime_type(absolute_path)\n      #model.header   =\n      #model.footer   =\n      model.requires  = rdoc_file.requires.map{ |r| r.name }\n      model.constants = rdoc_file.constants.map{ |c| c.full_name }\n\n      # note that this utilizes the table we are building\n      # so it needs to be the last thing done.\n      @table.each do |k, h|\n        case h['!']\n        when 'module'\n          model.modules ||= []\n          model.modules << k if h['files'].include?(rdoc_file.full_name)\n        when 'class'\n          model.classes ||= []\n          model.classes << k if h['files'].include?(rdoc_file.full_name)\n        when 'method'\n          model.methods ||= []\n          model.methods << k if h['file'] == rdoc_file.full_name\n        when 'class-method'\n          model.class_methods ||= []\n          model.class_methods << k if h['file'] == rdoc_file.full_name\n        end\n      end\n\n      @table['/'+model.path] = model.to_h\n    end\n  end\n\n  # Returns String of fully qualified name.\n  def complete_name(name, namespace)\n    if name !~ /^#{namespace}/\n      \"#{namespace}::#{name}\"\n    else\n      name\n    end\n  end\n\n  #\n  def collect_methods(class_module, singleton=false)\n    list = []\n    class_module.method_list.each do |m|\n      next if singleton ^ m.singleton\n      list << method_name(m)\n    end\n    list.uniq\n  end\n\n  def collect_attributes(class_module, singleton=false)\n    list = []\n    class_module.attributes.each do |a|\n      next if singleton ^ a.singleton\n      #p a.rw\n      #case a.rw\n      #when :write, 'W'\n      #  list << \"#{method_name(a)}=\"\n      #else\n        list << method_name(a)\n      #end\n    end\n    list.uniq\n  end\n\n  #\n  def method_name(method)\n    return nil if method.nil?\n    if method.singleton\n      i = method.full_name.rindex('::')     \n      method.full_name[0...i] + '.' + method.full_name[i+2..-1]\n    else\n      method.full_name\n    end\n  end\n\n  #\n  def mime_type(path)\n    case File.extname(path)\n    when '.rb', '.rbx' then 'text/ruby'\n    when '.c' then 'text/c-source'\n    when '.rdoc' then 'text/rdoc'\n    when '.md', '.markdown' then 'text/markdown'\n    else 'text/plain'\n    end\n  end\n\n  # Output progress information if rdoc debugging is enabled\n\n  def debug_msg(msg)\n    return unless $DEBUG_RDOC\n    case msg[-1,1]\n      when '.' then tab = \"= \"\n      when ':' then tab = \"== \"\n      else          tab = \"* \"\n    end\n    $stderr.puts(tab + msg)\n  end\n\nend\n\n\n\n\n=begin\n  #\n  # N O T  U S E D\n  #\n\n  # Sort based on how often the top level namespace occurs, and then on the\n  # name of the module -- this works for projects that put their stuff into\n  # a namespace, of course, but doesn't hurt if they don't.\n  def sort_salient(classes)\n    nscounts = classes.inject({}) do |counthash, klass|\n      top_level = klass.full_name.gsub( /::.*/, '' )\n      counthash[top_level] ||= 0\n      counthash[top_level] += 1\n      counthash\n    endfiles_toplevel\n    classes.sort_by{ |klass|\n      top_level = klass.full_name.gsub( /::.*/, '' )\n      [nscounts[top_level] * -1, klass.full_name]\n    }.select{ |klass|\n      klass.document_self\n    }\n  end\n=end\n\n=begin\n  # Loop through table and convert all named references into bonofied object\n  # references.\n  def reference_table(table)\n    debug_msg \"== Generating Reference Table\"\n    new_table = {}\n    table.each do |key, entry|\n      debug_msg \"%s\" % [key]\n      data = entry.dup\n      new_table[key] = data\n      case data['!']\n      when 'script'\n        data[\"constants\"]  = ref_list(data[\"constants\"])\n        data[\"modules\"]    = ref_list(data[\"modules\"])\n        data[\"classes\"]    = ref_list(data[\"classes\"])\n        data[\"functions\"]  = ref_list(data[\"functions\"])\n        data[\"methods\"]    = ref_list(data[\"methods\"])\n      when 'file'\n      when 'constant'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n      when 'module', 'class'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n        data[\"includes\"]   = ref_list(data[\"includes\"])\n        #data[\"extended\"]  = ref_list(data[\"extended\"])\n        data[\"constants\"]  = ref_list(data[\"constants\"])\n        data[\"modules\"]    = ref_list(data[\"modules\"])\n        data[\"classes\"]    = ref_list(data[\"classes\"])\n        data[\"functions\"]  = ref_list(data[\"functions\"])\n        data[\"methods\"]    = ref_list(data[\"methods\"])\n        data[\"files\"]      = ref_list(data[\"files\"])\n        data[\"superclass\"] = ref_item(data[\"superclass\"]) if data.key?(\"superclass\")\n      when 'method', 'function'\n        data[\"namespace\"]  = ref_item(data[\"namespace\"])\n        data[\"file\"]       = ref_item(data[\"file\"])\n      end\n    end\n    new_table\n  end\n\n  # Given a key, return the matching table item. If not found return the key.\n  def ref_item(key)\n    @table[key] || key\n  end\n\n  # Given a list of keys, return the matching table items.\n  def ref_list(keys)\n    #keys.map{ |k| @table[k] || k }\n    keys.map{ |k| @table[k] || nil }.compact\n  end\n\n=end\n","language":"text/ruby","requires":["fileutils","pathname","yaml","json","rdoc/rdoc","rdoc/generator","rdoc/generator/markup","shomen/metadata","shomen/model","shomen/rdoc/extensions"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/rdoc/extensions.rb":{"!":"script","path":"lib/shomen/rdoc/extensions.rb","name":"extensions.rb","mtime":"2011-09-24 13:42:55 -0400","source":"class RDoc::TopLevel\n  #\n  def to_h\n    {\n       :path     => path,\n       :name     => base_name,\n       :fullname => full_name,\n       :rootname => absolute_name,\n       :modified => last_modified,\n       :diagram  => diagram\n    }\n  end\n\n  #\n  #def to_json\n  #  to_h.to_json\n  #end\nend\n\n\nclass RDoc::ClassModule\n  #\n  def with_documentation?\n    document_self_or_methods || classes_and_modules.any?{ |c| c.with_documentation? }\n  end\n\n  #\n  def document_self_or_methods\n    document_self || method_list.any?{ |m| m.document_self }\n  end\n\n#  #\n#  def to_h\n#    {\n#      :name       => name,\n#      :fullname   => full_name,\n#      :type       => type,\n#      :path       => path,\n#      :superclass => module? ? nil : superclass\n#    }\n#  end\n#\n#  def to_json\n#    to_h.to_json\n#  end\nend\n\n\nmodule RDoc::SourceCodeAccess\n\n  #\n  def source_code_raw\n    return '' unless @token_stream\n    src = \"\"\n    @token_stream.each do |t|\n      next unless t\n      src << t.text\n    end\n    #add_line_numbers(src)\n    src\n  end\n\n  #\n  def source_code_location\n    src = source_code_raw\n    if md = /File (.*?), line (\\d+)/.match(src)\n      file = md[1]\n      line = md[2]\n    else\n      file = \"(unknown)\"\n      line = 0\n    end\n    return file, line\n  end\n\nend\n\n\nclass RDoc::AnyMethod\n  include RDoc::SourceCodeAccess\n\n#  # NOTE: dont_rename_initialize isn't used\n#  def to_h\n#    {\n#      :name         => name,\n#      :fullname     => full_name,\n#      :prettyname   => pretty_name,\n#      :path         => path,\n#      :type         => type,\n#      :visibility   => visibility,\n#      :blockparams  => block_params,\n#      :singleton    => singleton,\n#      :text         => text,\n#      :aliases      => aliases,\n#      :aliasfor     => is_alias_for,\n#      :aref         => aref,\n#      :parms        => params,\n#      :callseq      => call_seq\n#      #:paramseq     => param_seq,\n#    }\n#  end\n\n#  #\n#  def to_json\n#    to_h.to_json\n#  end\nend\n\nclass RDoc::Attr\n  include RDoc::SourceCodeAccess\nend\n\n\n# DEPRECATE ASAP\nrequire \"rdoc/parser/c\"\n# New RDoc somehow misses class comemnts.\n# copyied this function from \"2.2.2\" \nif ['2.4.2', '2.4.3'].include? RDoc::VERSION\n  class RDoc::Parser::C\n    def find_class_comment(class_name, class_meth)\n      comment = nil\n      if @content =~ %r{((?>/\\*.*?\\*/\\s+))\n                     (static\\s+)?void\\s+Init_#{class_name}\\s*(?:_\\(\\s*)?\\(\\s*(?:void\\s*)\\)}xmi then\n        comment = $1\n      elsif @content =~ %r{Document-(?:class|module):\\s#{class_name}\\s*?(?:<\\s+[:,\\w]+)?\\n((?>.*?\\*/))}m\n        comment = $1\n      else\n        if @content =~ /rb_define_(class|module)/m then\n          class_name = class_name.split(\"::\").last\n          comments = []\n          @content.split(/(\\/\\*.*?\\*\\/)\\s*?\\n/m).each_with_index do |chunk, index|\n            comments[index] = chunk\n            if chunk =~ /rb_define_(class|module).*?\"(#{class_name})\"/m then\n              comment = comments[index-1]\n              break\n            end\n          end\n        end\n      end\n      class_meth.comment = mangle_comment(comment) if comment\n    end\n  end\nend\n\n\n","language":"text/ruby","requires":["rdoc/parser/c"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/server.rb":{"!":"script","path":"lib/shomen/server.rb","name":"server.rb","mtime":"2011-09-24 13:42:55 -0400","source":"require 'sinatra'\n\nset :run, true\nset :static, true\nset :public, ARGV[1] || Dir.pwd\n\nget '/' do\n  redirect 'index.html'\nend\n\n","language":"text/ruby","requires":["sinatra"],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/tomdoc.rb":{"!":"script","path":"lib/shomen/tomdoc.rb","name":"tomdoc.rb","mtime":"2011-09-24 13:42:55 -0400","source":"# TODO\n","language":"text/ruby","requires":[],"constants":[],"classes":[],"modules":[],"methods":[]},"/lib/shomen/yard.rb":{"!":"script","path":"lib/shomen/yard.rb","name":"yard.rb","mtime":"2011-09-24 13:42:55 -0400","source":"require 'yard'\nrequire 'shomen/metadata'\nrequire 'shomen/model'\n\nmodule Shomen\n\n  # This adapter is used to convert YARD's documentation extracted\n  # from a local store (`.yardoc`) to Shomen's pure-data format.\n  #\n  class YardAdaptor\n\n    # The hash object that is used to store the generated \n    # documentation.\n    attr :table\n\n    # New adaptor.\n    def initialize(options)\n      @db    = options[:db]    || '.yardoc'\n      @files = options[:files] || ['lib', 'README*']\n    end\n\n    # Generate the shomen data structure.\n    def generate\n      if not File.exist?(@db)\n        $stderr.puts \"ERROR: YARD database not found -- '#{@db}`.\"\n        exit -1\n      end\n\n      @table = {}\n\n      generate_metadata\n\n      @registry = YARD::Registry.load!(@db)\n      @registry.each do |object|\n        case object.type\n        when :constant\n          generate_constant(object)\n        when :class, :module\n          generate_class(object)\n          # TODO: is this needed?\n          object.constants.each do |c|\n            generate_constant(c)\n          end\n        #when :module\n        #  generate_module(object)\n        #  # TODO: is this needed?\n        #  object.constants.each do |c|\n        #    generate_constant(c)\n        #  end\n        when :method\n          generate_method(object)\n        else\n          $stderr.puts \"What is an #{object.type}? Ignored!\"\n        end\n      end\n\n      # TODO: Are c/c++ sourse files working okay?\n      # TODO: Add a generator for non-ruby script (e.g. .js)?\n      collect_files.each do |file|\n        case File.extname(file)\n        when '.rb', '.rbx', '.c', '.cpp'\n          generate_script(file)\n        when '.rdoc', '.md', '.markdown', '.txt'\n          generate_document(file)\n        else\n          generate_document(file)\n        end\n      end\n    end\n\n  private\n\n    # Collect files given list of +globs+.\n    def collect_files\n      globs = @files\n      globs = globs.map{ |glob| Dir[glob] }.flatten.uniq\n      globs = globs.map do |glob|\n        if File.directory?(glob)\n          Dir[File.join(glob, '**/*')]\n        else\n          glob\n        end\n      end\n      list = globs.flatten.uniq.compact\n      list = list.reject{ |path| File.extname(path) == '.html' }\n      list = list.select{ |path| File.file?(path) }\n      list\n    end\n\n    # Generate project metadata entry.\n    #\n    # @return [Hash] metadata added to the documentation table\n    def generate_metadata\n      metadata = Metadata.new\n\n      @table['(metadata)'] = metadata.to_h\n    end\n\n    # Generate a class or module structure.\n    #\n    # @note As to whether `methods` also contains the accessor methods\n    #   listed in `accessors` is left to YARD to determine.\n    #   \n    # @return [Hash] class data that has been placed in the table\n    def generate_class(yard_class)\n      debug_msg(yard_class.path.to_s)\n\n      meths = yard_class.meths(:included=>false, :inherited=>false)\n\n      if yard_class.type == :class\n        model = Model::Class.new\n        model.superclass = yard_class.superclass ? yard_class.superclass.path : 'Object'\n      else \n        model = Model::Module.new\n      end\n\n      model.path            = yard_class.path\n      model.name            = yard_class.name.to_s\n      model.namespace       = yard_class.namespace.path  #full_name.split('::')[0...-1].join('::'),\n      model.comment         = yard_class.docstring.to_s\n      model.format          = 'rdoc'  #TODO: how to determine? rdoc, markdown or plaintext ?\n      model.constants       = yard_class.constants.map{ |x| x.path }  #TODO: complete_name(x.name, c.full_name) }\n      model.includes        = yard_class.instance_mixins.map{ |x| x.path }\n      model.extensions      = yard_class.class_mixins.map{ |x| x.path }\n      model.modules         = yard_class.children.select{ |x| x.type == :module }.map{ |x| x.path }\n                              #yard_class.modules.map{ |x| complete_name(x.name, c.full_name) }\n      model.classes         = yard_class.children.select{ |x| x.type == :class }.map{ |x| x.path }\n                              #yard_class.classes.map{ |x| complete_name(x.name, c.full_name) }\n\n      model.methods         = meths.select.map{ |m| m.path }\n      #model.methods         = meths.select{ |m| m.scope == :instance }.map{ |m| m.path }\n      #model.class_methods   = meths.select{ |m| m.scope == :class }.map{ |m| m.path }\n\n      model.accessors       = yard_class.attributes[:class].map{ |k, rw| yard_class.path + '.' + k.to_s } +\n                              yard_class.attributes[:instance].map{ |k, rw| yard_class.path + '#' + k.to_s }\n      #model.class_accessors = yard_class.attributes[:class].map{ |k, rw| yard_class.path + '.' + k.to_s }\n\n      model.files           = yard_class.files.map{ |f, l| \"/#{f}\" } # :#{l}\" }\n\n      model.tags            = translate_tags(yard_class)\n\n      #@files.concat(yard_class.files.map{ |f, l| f })\n\n      @table[model.path] = model.to_h\n    end\n\n=begin\n    # Generate a module structure.\n    #\n    def generate_module(object)\n      index = object.path.to_s\n      #meths = object.meths(:included=>false, :inherited=>false)\n\n      debug_msg(index)\n\n      data = Model::Module.new(Yard::ModuleAdapter.new(object)).to_h\n\n      #data = Shomen::Model::Module.new(\n      #  'name'          => object.name.to_s,\n      #  'namespace'     => object.namespace.path, #full_name.split('::')[0...-1].join('::')\n      #  'comment'       => object.docstring.to_s,\n      #  'constants'     => object.constants.map{ |x| x.path }, #complete_name(x.name, c.full_name) }\n      #  'includes'      => object.instance_mixins.map{ |x| x.path },\n      #  'extensions'    => object.class_mixins.map{ |x| x.path },\n      #  'modules'       => object.children.select{ |x| x.type == :module }.map{ |x| x.path }, \n      #                     #object.modules.map{ |x| complete_name(x.name, c.full_name) }\n      #  'classes'       => object.children.select{ |x| x.type == :class }.map{ |x| x.path },\n      #                     #object.classes.map{ |x| complete_name(x.name, c.full_name) }\n      #  'methods'       => meths.select{ |m| m.scope == :instance }.map{ |m| m.path },\n      #  'class-methods' => meths.select{ |m| m.scope == :class }.map{ |m| m.path },\n      #  #'attributes'       => meths.select{ |m| m.scope == :instance }.map{ |m| m.path },\n      #  #'class-attributes' => meths.select{ |m| m.scope == :class }.map{ |m| m.path },\n      #  'files'         => object.files.map{ |f, l| \"/#{f}:#{l}\" }\n      #).to_h\n\n      #@files.concat(object.files.map{ |f, l| f })\n\n      @table[index] = data\n    end\n=end\n\n    # Generate a method structure.\n    #\n    def generate_method(yard_method)\n      debug_msg(yard_method.to_s)\n\n      model = Model::Method.new\n      #class_model = object.scope == :instance ? Shomen::Module::Method : Shomen::Model::Function\n\n      model.path        = yard_method.path\n      model.name        = yard_method.name.to_s\n      model.namespace   = yard_method.parent.path  \n      model.comment     = yard_method.docstring.to_s\n      model.format      = 'rdoc'  # TODO: how to determine? rdoc, markdown or plain \n      model.aliases     = yard_method.aliases.map{ |a| a.path }  #method_name(a) }\n      # TODO: how to get alias_for from YARD?\n      #model.alias_for = method_name(yard_method.alias_for)\n      model.singleton   = (yard_method.scope == :class)\n\n      model.declarations << yard_method.scope.to_s\n      model.declarations << yard_method.visibility.to_s\n      # FIXME\n      #model.declarations << yard_method.attr_info\n\n      model.interfaces = []\n      yard_method.tags.each do |tag|\n        case tag\n        when ::YARD::Tags::OverloadTag\n          model.interfaces << parse_interface(tag)\n        end\n      end\n      model.interfaces << parse_interface(yard_method)\n\n      model.returns = (\n        rtns = []\n        yard_method.tags(:return).each do |tag|\n          tag.types.each do |t|\n            rtns << {'type'=>t, 'comment'=>tag.text}\n          end\n        end\n        rtns\n      )\n\n      model.file     = '/'+yard_method.file\n      model.line     = yard_method.line.to_i\n      model.source   = yard_method.source\n      model.language = yard_method.source_type.to_s\n      model.dynamic  = yard_method.dynamic\n\n      model.tags     = translate_tags(yard_method)\n\n      @table[model.path] = model.to_h\n    end\n\n    # Parse a yard method's interface.\n    def parse_interface(yard_method)\n      args, block = [], {}\n\n      image, returns = yard_method.signature.split(/[=-]\\>/)\n\n      image = image.strip\n      if i = image.index(/\\)\\s*\\{/)\n        block['image'] = image[i+1..-1].strip\n        image          = image[0..i].strip\n      end\n      image = image.sub(/^def\\s*/, '')\n      image = image.sub(/^self\\./, '')\n      image = image.sub('( )','()')\n\n      yard_method.parameters.each do |n,v|\n        n = n.to_s\n        case n\n        when /^\\&/\n          block['name'] = n\n        else\n          args << (v ? {'name'=>n,'default'=>v} : {'name'=>n})\n        end\n      end\n\n      result = {}\n      result['signature']  = image\n      result['arguments']  = args\n      #result['parameters'] = params\n      result['block']      = block unless block.empty?\n      result['returns']    = returns.strip if returns\n      result\n    end\n    private :parse_interface\n\n    # Generate a constant.\n    #\n    def generate_constant(yard_constant)\n      debug_msg(yard_constant.path.to_s)\n\n      model = Model::Constant.new\n\n      model.path      = yard_constant.path\n      model.name      = yard_constant.name.to_s\n      model.namespace = yard_constant.namespace.path  \n      model.comment   = yard_constant.docstring.to_s\n      model.format    = 'rdoc'  #  TODO: how to determine? rdoc, markdown or plain \n      model.value     = yard_constant.value\n      model.tags      = translate_tags(yard_constant)\n      model.files     = yard_constant.files.map{|f,l| \"/#{f}\"}  # or \"#{f}:#{l}\" ?\n\n      @table[model.path] = model.to_h\n    end\n\n    # Generate a file.\n    #\n    def generate_document(yard_document)\n      debug_msg(yard_document)\n\n      model = Model::Document.new\n\n      # FIXME: make absolute\n      absolute_path = yard_document.to_s\n\n      model.path   = yard_document.to_s\n      model.name   = File.basename(absolute_path)\n      model.mtime  = File.mtime(absolute_path)\n      model.text   = File.read(absolute_path)\n      model.format = mime_type(absolute_path)\n\n      @table['/'+model.path] = model.to_h\n    end\n\n    # Generate a script entry.\n    #\n    def generate_script(yard_script)\n      debug_msg(yard_script)\n\n      model = Model::Script.new\n\n      # FIXME: make absolute\n      absolute_path = yard_script.to_s\n\n      model.path     = yard_script.to_s\n      model.name     = File.basename(absolute_path)\n      model.mtime    = File.mtime(absolute_path)\n      model.source   = File.read(absolute_path)\n      model.language = mime_type(absolute_path)\n\n      #  model.header        = \"\"\n      #  model.footer        = \"\"\n      #  model.requires      =\n      #  model.constants     =\n      #  model.modules       =\n      #  model.classes       =\n      #  model.methods       =\n      #  model.class_methods =\n\n      @table['/'+model.path] = model.to_h\n\n      #table[index] = Shomen::Model::Script.new(\n      #  \"name\"        => File.basename(object),\n      #  \"path\"        => object,\n      #  #\"loadpath\"    => \"lib\",\n      #  \"mtime\"       => File.mtime(object),\n      #  \"header\"      => \"\",\n      #  \"footer\"      => \"\",\n      #  # \"requires\"    : [\"fileutils\"],\n      #  # \"constants\"   : [\"MusicStore::CONFIG_DIRECTORY\"],\n      #  # \"modules\"     : [\"MusicStore\", \"MusicStore::MusicMixin\"],\n      #  # \"classes\"     : [\"MusicStore::Song\"],\n      #  # \"functions\"   : [\"MusicStore.config_directory\"],\n      #  # \"methods\"     : [\"MusicStore::MusicMixin#play\", \"MusicStore::MusicMixin#artist\"]\n      #  \"source\"      => File.read(object)\n      #).to_h\n\n      @table['/'+model.path] = model.to_h\n    end\n\n    # Output progress information if debugging is enabled\n    #\n    def debug_msg(msg)\n      return unless $DEBUG\n      case msg[-1,1]\n        when '.' then tab = \"= \"\n        when ':' then tab = \"== \"\n        else          tab = \"* \"\n      end\n      $stderr.puts(tab + msg)\n    end\n\n    # Given a file return offical mime-type basic on file extension.\n    #\n    # FIXME: official mime types?\n    def mime_type(path)\n      case File.extname(path)\n      when '.rb', '.rbx'      then 'text/x-ruby'\n      when '.c'               then 'text/c-source'  # x-c-code\n      when '.js'              then 'text/ecmascript'\n      when '.rdoc'            then 'text/rdoc'\n      when '.md', '.markdown' then 'text/markdown'\n      else 'text/plain'\n      end\n    end\n\n    # Convert YARD Tags to simple Hash.\n    #\n    # TODO: Remove param tags?\n    def translate_tags(yard_object)\n      tags = {}\n      yard_object.tags.each do |tag|\n        next if tag.tag_name == 'return'\n        tags[tag.tag_name] = tag.text\n      end\n      return tags\n    end\n\n  end\n\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=begin\n    # Generate a method structure.\n    #\n    def generate_attribute(object)\n      index = \"#{object.path}\"\n\n      debug_msg(index)\n\n      data = Model::Method.new(Yard::MethodAdapter.new(object)).to_h\n\n      ##code       = m.source_code_raw\n      ##file, line = m.source_code_location\n\n      ##full_name = method_name(m)\n\n      ##'prettyname'   => m.pretty_name,\n      ##'type'         => m.type, # class or instance\n\n      #args = []\n      #object.parameters.each do |var, val|\n      #  if val\n      #    args << { 'name' => var, 'default'=>val }\n      #  else\n      #    args << { 'name' => var }\n      #  end\n      #end\n      #\n      #rtns = []\n      #object.tags(:return).each do |t|\n      #  t.types.each do |ty|\n      #    rtns << { 'type' => ty, 'comment' => t.text }\n      #  end\n      #end\n      #\n      #table[index] = Shomen::Model::Attribute.new(\n      #  'name'         => object.name.to_s,\n      #  'namespace'    => object.parent.path,\n      #  'comment'      => object.docstring.to_s,\n      #  'access'       => object.visibility.to_s,\n      #  'singleton'    => object.scope == :class,\n      #  'aliases'      => object.aliases.map{ |a| a.path }, #method_name(a) },\n      #  #'alias_for'    => method_name(m.is_alias_for),\n      #  'interfaces'   => [{'interface'  => object.signature.sub('def ', ''), #m.params,\n      #                      'arguments'  => args,\n      #                      'parameters' => []\n      #                      #'block'     => m.block_params, # TODO: what is block?\n      #                    }],\n      #  'returns'      => rtns,\n      #  'file'         => \"/#{object.file}\",\n      #  'line'         => object.line,\n      #  'source'       => object.source,\n      #  'language'     => object.source_type.to_s,\n      #  'dynamic'      => object.dynamic\n      #).to_h\n\n      @table[index] = model.to_h\n    end\n=end\n\n","language":"text/ruby","requires":["yard","shomen/metadata","shomen/model"],"constants":[],"classes":[],"modules":[],"methods":[]}}
